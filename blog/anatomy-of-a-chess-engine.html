<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Deniz's personal pages</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <script src="/js/vendor/es5-shim.min.js"></script>
        <script src="/js/vendor/marked.min.js"></script>
        <!--script src="/js/vendor/purify.min.js"></script-->
        <script src="/js/vendor/ansi_up.min.js"></script>
        <script src="/js/vendor/prism.min.js"></script>
        <script src="/js/vendor/katex.min.js"></script>
        <script src="/js/vendor/katex-auto-render.min.js"></script>
	<script src="/js/vendor/notebook.js?_=2021-07-21 17:16:06"></script>
        <link rel="stylesheet" href="/css/vendor/katex.min.css" />
        <link rel="stylesheet" href="/css/vendor/prism.css" />
	<link rel="stylesheet" href="/css/notebook.css?2021-07-21 17:16:06" />
	<link rel="stylesheet" href="/css/nbpreview.css?2021-07-21 17:16:06" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet">
        <script type="application/text" id="source">
          {"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# anatomy of a chess engine\n", "", "2015-05-09t23:08:34-07:00 [#programming](/tag/programming.html) [#chess](/tag/chess.html)\n"]}, {"cell_type": "markdown", "metadata": {"tags": ["programming", "chess"]}, "source": ["\n", "Let's check out the anatomy of a chess engine.\n", "\n", "Board Representation\n", "====================\n", "\n", "The first thing we will tackle in programming our chess engine is a representation of the board. We will use the technique called a 10\u00d712 board with sentinel markers. In this method the 8\u00d78 chess board is wrapper with an extra 2 rows at the top and bottom and extra rows on the right and left side as in the figure\n", "\n", "![](/img/10x12-board.png)\n", "\n", "The blue squares are the actual chess board and the orange squares the sentinel squares that will come in handy when we are generating moves. You can think of the board as a 2 dimensional array in java. The square with the number 21 is the A1 square and the square 98 is the H8 square of the chess board. We will place our chess pieces in the array locations in this array. So say for example if a white pawn was represented with the value 2 then\n", "\n", "`Board[21] = 2`\n", "\n", "would mean that there is a white pawn on A1 (which is not a legal board state for chess \u2013 but just for the sake of an example bear with it)\n", "\n", "So let's dive right in and define a few classes that we will need to represent the board. First of some key squares that we will use throughout our engine go into a class\n", "\n", "```\n", "public class Squares {\n", "    public static final int A1 = 21;\n", "    public static final int B1 = 22;\n", "    public static final int C1 = 23;\n", "    public static final int D1 = 24;\n", "    public static final int E1 = 25;\n", "    public static final int F1 = 26;\n", "    public static final int G1 = 27;\n", "    public static final int H1 = 28;\n", " \n", "    public static final int A8 = 91;\n", "    public static final int B8 = 92;\n", "    public static final int C8 = 93;\n", "    public static final int D8 = 94;\n", "    public static final int E8 = 95;\n", "    public static final int F8 = 96;\n", "    public static final int G8 = 97;\n", "    public static final int H8 = 98;\n", "    public static final int NOSQ = 99;\n", "    public static final int OFFBOARD = 100;\n", "```\n", "now we will define some enumerations to make the code more programmer friendly so we don't see magic numbers everywhere\n", "\n", "\n", "\n", "```\n", "public class Rank {\n", "    public static final int RANK_1 = 0;\n", "    public static final int RANK_2 = 1;\n", "    public static final int RANK_3 = 2;\n", "    public static final int RANK_4 = 3;\n", "    public static final int RANK_5 = 4;\n", "    public static final int RANK_6 = 5;\n", "    public static final int RANK_7 = 6;\n", "    public static final int RANK_8 = 7;\n", "    public static final int RANK_NONE = 8;\n", "}\n", "\n", "public class File {\n", "\n", "    public static final int FILE_A = 0;\n", "    public static final int FILE_B = 1;\n", "    public static final int FILE_C = 2;\n", "    public static final int FILE_D = 3;\n", "    public static final int FILE_E = 4;\n", "    public static final int FILE_F = 5;\n", "    public static final int FILE_G = 6;\n", "    public static final int FILE_H = 7;\n", "    public static final int FILE_NONE = 8;\n", "}\n", "\n", "public class File {\n", " \n", "    public static final int FILE_A = 0;\n", "    public static final int FILE_B = 1;\n", "    public static final int FILE_C = 2;\n", "    public static final int FILE_D = 3;\n", "    public static final int FILE_E = 4;\n", "    public static final int FILE_F = 5;\n", "    public static final int FILE_G = 6;\n", "    public static final int FILE_H = 7;\n", "    public static final int FILE_NONE = 8;\n", "}\n", "\n", "public class Color {\n", "    public static final int WHITE = 0;\n", "    public static final int BLACK = 1;\n", "    public static final int BOTH = 2;\n", "}\n", "\n", "public class Color {\n", "    public static final int WHITE = 0;\n", "    public static final int BLACK = 1;\n", "    public static final int BOTH = 2;\n", "}\n", "\n", "public class Piece {\n", "    public static final int EMPTY = 0;\n", "    public static final int wP = 1;\n", "    public static final int wN = 2;\n", "    public static final int wB = 3;\n", "    public static final int wR = 4;\n", "    public static final int wQ = 5;\n", "    public static final int wK = 6;\n", "    public static final int bP = 7;\n", "    public static final int bN = 8;\n", "    public static final int bB = 9;\n", "    public static final int bR = 10;\n", "    public static final int bQ = 11;\n", "    public static final int bK = 12;\n", "}\n", "\n", "public class Piece {\n", "    public static final int EMPTY = 0;\n", "    public static final int wP = 1;\n", "    public static final int wN = 2;\n", "    public static final int wB = 3;\n", "    public static final int wR = 4;\n", "    public static final int wQ = 5;\n", "    public static final int wK = 6;\n", "    public static final int bP = 7;\n", "    public static final int bN = 8;\n", "    public static final int bB = 9;\n", "    public static final int bR = 10;\n", "    public static final int bQ = 11;\n", "    public static final int bK = 12;\n", "}\n", "```\n", "\n", "Ok these classes are pretty self-explanatory they are a bunch of definitions. Now for some real stuff\n", "\n", "```\n", "public class Board {\n", "    public static final int NUM_SQ = 120;\n", "    int[] filesBoard = new int[NUM_SQ];\n", "    int[] ranksBoard = new int[NUM_SQ];\n", " \n", "    private static Board instance;\n", " \n", "    private Board() {\n", " \n", "        init();\n", "    }\n", " \n", "    public static Board getInstance() {\n", "        if (instance == null) {\n", "            instance = new Board();\n", "        }\n", "        return instance;\n", "    }\n", " \n", "    public static int fileRank2Square(int file, int rank) {\n", "        return 21 + file + rank * 10;\n", "    }\n", " \n", "    public void init() {\n", " \n", "        for (int i = 0; i < NUM_SQ; i++) { // part 1\n", "            filesBoard[i] = Squares.OFFBOARD;\n", "            ranksBoard[i] = Squares.OFFBOARD;\n", "        }\n", " \n", "        for (int file = File.FILE_A; file <= File.FILE_H ; file++) { // part 2\n", "            for (int rank = Rank.RANK_1; rank <= Rank.RANK_8; rank++) {\n", "                int sq = Board.fileRank2Square(file, rank);\n", "                filesBoard[sq] = file;\n", "                ranksBoard[sq] = rank;\n", "            }\n", "        }\n", " \n", "    }\n", "}\n", "```\n", "\n", "So we have here a basic initialization of the board. We have 2 arrays here that need attention: filesBoard and  ranksBoard . These two arrays hold the values for ranks and files. So after initialized the files board will look like\n", "\n", "![](/img/10x12-fileboard.png)\n", "\n", "and the rank file board will look like\n", "\n", "![](/img/10x12-rankboard.png)\n", "\n", "We have also a method that will return the index of a square for the given file and rank. So now on to the initialization part. First off we go and set everything slot in both arrays to an off square value to initialize the sentinel squares. Then we loop from file A rank 1 to file H rank 8 basically iterating over all of the squares on the chess board and set the file and rank values appropriately. After this initialization code has run the state of the arrays will like the figures above.\n", "\n", "Now lets write a test to make sure that our code is working as expected\n", "\n", "```\n", "@Test\n", "    public void testFilesBoardInit() {\n", "        Board b = Board.getInstance();\n", "        assertTrue(b.ranksBoard[0] == Squares.OFFBOARD);\n", "        assertTrue(b.ranksBoard[Squares.A1] == Rank.RANK_1);\n", "        assertTrue(b.filesBoard[Squares.A1] == File.FILE_A);\n", " \n", "        assertTrue(b.filesBoard[Squares.C8] == File.FILE_C);\n", "        assertTrue(b.ranksBoard[Squares.C8] == Rank.RANK_8);\n", "    }\n", "```\n", "\n", "Board Flags\n", "===========\n", "\n", "next some more variables in our board class to hold some board states.\n", "\n", "```\n", "int[] pieces = new int[NUM_SQ];\n", "    int side = Color.WHITE;\n", "    int fiftyMoves = 0;\n", "    int historyPly = 0;\n", "    int ply = 0;\n", "    int castlePerms = 0;\n", "\n", "```\n", "\n", "the pieces  array will hold the actual pieces as values that we defined in the Pieces class.\n", "\n", "the side  variable holds the current side to move, we just initialize it to white but later we may change it according to a given starting position.\n", "\n", "the fiftyMove  variable is used to determine a draw by fifty moves. This is a lesser known rule in chess so check out this wikipedia page if you don\u2019t know the rule. This variable will get incremented for every move made, and will be reset if a pawn move or a capture happens. If the value every reaches 100 (that\u2019s in half moves, so it\u2019s 50 full moves) then either side is eligible to claim a draw.\n", "\n", "the historyPly  is the number of half-moves (a move by one side) since the beginning of the game. We will use this as an index for undoing moves later.\n", "\n", "the ply  variable is the number of moves in the search tree. Don\u2019t worry about this \u2013 you will understand how it is used during the searching phase and move generation.\n", "\n", "the castlePerms  holds the castling permissions for both sides in an integer. The least significant bit represents white king side castling and the next white queen side castling and so on. So it takes 4 bits to represent all castling permissions. In the class CastleMask we define these bits. So to check if a white can castle king side all we need to do is bit wise and the castlePerms  variable with the corresponding value in CastleMask . Bit wise operations are a bit scary for most people so brush up on your bit wise operations by checking out this article.\n", "\n", "Here is the CastleMask class that we use to check the castling permissions\n", "\n", "```\n", "public class CastleMask {\n", "    int wk = 1;\n", "    int wq = 2;\n", "    int bk = 4;\n", "    int bq = 8;\n", "}\n", "```\n", "\n", "So for example if the castle permissions had a value of 3 which is 0011 in binary and we wanted to check if white can castle queen side we would do this operation castlePerm & CastleMask.wq  and check if the result of this operation is 0 or 1. If it is 1 then white can castle queen side. If you apply this operation 0011 and 0010 ( CastleMask.wq  is 2 which is this in binary) the result will be 1 so white can castle queen side.\n", "\n", "\n", "Piece lists\n", "===========\n", "\n", "When we want to generate moves for the pieces on the board the first approach that comes to mind is looping through all the squares on the board and checking if the current square has a piece of the correct color for the side to move and generating the moves for that piece. But by using some extra memory \u2013 only very little we can do a bit better. Instead of going through the squares we will track pieces and know on which square that piece is currently sitting. Before we implement this idea lets add a few convenience variable that we will use later on for look-ups. So in Piece.java we need the following\n", "\n", "\n", "```\n", "    public int[] pieces = new int[]{EMPTY, wP, wN, wB, wR, wQ, wK, bP, bN, bB, bR, bQ, bK};\n", "    public boolean[] pieceBig = new boolean[]{false, false, true, true, true, true, true, false, true, true, true, true, true};\n", "    public boolean[] pieceMaj = new boolean[]{false, false, false, false, true, true, true, false, false, false, true, true, true};\n", "    public boolean[] pieceMin = new boolean[]{false, false, true, true, false, false, false, false, true, true, false, false, false};\n", "    public int[] pieceVal = new int[]{0, 100, 325, 325, 550, 1000, 50000, 100, 325, 325, 550, 1000, 50000};\n", "    public int[] pieceCol = new int[]{Color.BOTH, Color.WHITE, Color.WHITE, Color.WHITE, Color.WHITE, Color.WHITE, \n", "        Color.WHITE,Color.BLACK, Color.BLACK, Color.BLACK, Color.BLACK, Color.BLACK, Color.BLACK};\n", "    public boolean[] piecePawn = new boolean[]{false, true, false, false, false, false, false, true, false, false, false, false, false};\n", "    public boolean[] pieceKnight = new boolean[]{false, false, true, false, false, false, false, false, true, false, false, false, false};\n", "    public boolean[] pieceKing = new boolean[]{false, false, false, false, false, false, true, false, false, false, false, false, true};\n", "    public boolean[] pieceRookQueen = new boolean[]{false, false, false, false, true, true, false, false, false, false, true, true, false};\n", "    public boolean[] pieceBishopQueen = new boolean[]{false, false, false, true, false, true, false, false, false, true, false, true, false};\n", "    public boolean[] pieceSlides = new boolean[]{false, false, false, true, true, true, false, false, false, true, true, true, false};\n", "\n", "```\n", "\n", "These are just some look-up tables and they are pretty simple but I\u2019ll explain one just as an example. The pieceVal[]  array holds the values for each piece indexed by the piece index in the pieces[]  array. So the first element in the  pieces[]  array is EMPTY with an index of 0. The the element at pieceVal[0]  is also 0 because an empty piece does not have a value. The next element in the pieces[]  array at pieces[1]  is a white pawn. So the value in the pieceVal[1]  array is 100 signifying the value of a pawn etc. You get the basic idea behind this, feel free to leave a comment if anything is unclear.\n", "\n", "Now let\u2019s get back to the piece lists. In Board.java we need the following arrays\n", "\n", "\n", "```\n", "int[] material = new int[2]; //WHITE,BLACK;\n", "    int[] pceNum = new int[13];\n", "    int[] pList = new int[130];\n", "    int enPassantSquare = 0;\n", "```\n", "\n", "The material[]  array holds the total value of material present at the board indexed by color. So if the white side has a single pawn on the board material[0]  would 100. Simple enough.\n", "\n", "The pceNum[]  array holds the number of pieces of a certain type on the board. This is again using the Piece.pieces[]  as the index. So the index of a white pawn is 1 in the pieces array, so pceNum[1]  would be 5 if there were 5 white pawns on the board. The pList[] array holds the squares for each of the pieces on the board. There can be a maximum of 10 pieces of the same kind on the board at a given state. How is that possible you ask? This is an edge case but think about this scenario: I promote each of may eight pawns to rooks and I already have my two rooks so that makes a total of ten rooks for me. Taking this logic into account we set aside ten slots for each piece. So the following position\n", "\n", "![](/img/ah9syj4hw36s.png)\n", "\n", "would have pceNum[1]  = 8 and pList = [0,0,0,0,0,0,0,0,A2,B2,C2,...]  where A2 is the actual integer value of the board index. To get the square from the piece list all we have to do is multiply the piece integer representation by 10 and to get the beginning index in the pList[] array then we can get the next pceNum[piece integer value] elements. Let\u2019s add that to the Board class\n", "\n", "\n", "```\n", "  public static int pieceIndex(int piece, int pieceNum) {\n", "        return piece * 10 + pieceNum;\n", "    }\n", "\n", "```\n", "\n", "Position Hashing\n", "================\n", "\n", "In this part we will lay the foundation of our position hashing. Position hashing is mapping a unique value to each unique position on the board. What makes a position unique? It\u2019s basically the pieces on the board, and which squares they are on. If we have two knights on the board we cannot call this unique because we haven\u2019t stated the squares the knights are on. But if we say two knights on the board on squares A1 and A8 we can say this is a unique position. We also have to factor in the side to play, the castling statuses and any en passant squares (If you don\u2019t know what en passant means, take a look here). We will use a method called zorbist hashing to achieve this. The essentials of the hashing algorithm are like this: First we generate a random number for pieces on the board and XOR this with the current key. Then we XOR the resulting value with the side to move and XOR the resulting key with the en passant square etc until we have used all our defining attributes. Let\u2019s do an example to solidify. Say that we have 3 pieces p1, p2 and p3 and our key k.\n", "\n", "\n", "```\n", "p1 = random();\n", "p2 = random();\n", "p3 = random();\n", "k = 0;\n", "```\n", "\n", "we initialized our pieces and our key. Next up XOR\n", "\n", "\n", "```\n", "k = k XOR p1\n", "k = k XOR p2\n", "k = k XOR p3\n", "```\n", "\n", "this will yield our final key for the position (we have discarded en passant and the other stuff for simplicity). The nice thing about this hashing is that if we want to take out p1 from the hash we don\u2019t have to reconstruct the hash from the beginning for p2 and p3, we can just XOR p1 out of the hash like this\n", "\n", "\n", "```\n", "k = k XOR p1\n", "```\n", "\n", "and this would give the same result as doing\n", "\n", "\n", "```\n", "k = 0\n", "k = k XOR p2\n", "k = k XOR p3\n", "```\n", "\n", "So here is our random number generator and our variable to hold the position key that goes into our Board class\n", "\n", "\n", "```\n", "public static int random() {\n", "        return ((int)Math.floor((Math.random()*255)+1) << 23) | ((int)Math.floor((Math.random()*255)+1) << 16)\n", "                | ( (int) Math.floor((Math.random()*255)+1) << 8) | (int) Math.floor((Math.random()*255)+1);\n", " \n", "    }\n", "    int posKey = 0;\n", "\n", "```\n", "\n", "Position hashing and key generation\n", "===================================\n", "\n", "In this part we will incorporate the hashing into our engine. We will introduce a new class called Hash that will take care of all hashing related functions. We will need to initialize a table for each piece and square combination, a hashing key for side to move and for the castling permissions. Here is the definition part in code\n", "\n", "```\n", "public  int[] pieceKeys = new int[13 * 120];\n", "    public  int sideKey;\n", "    public  int[] castleKey = new int[16];\n", "    public static Hash instance;\n", "\n", "```\n", "\n", "The reason we are using 13 x 120 is that our board has sentinel squares around it and it\u2019s a total of 120 squares for 13 piece types. The castling permissions is a 4 bit number which is 16 in decimal so we use an array of length 16. We will be applying the singleton pattern that is why we defined an instance variable. Now let\u2019s initialize these tables with some values\n", "\n", "\n", "```\n", "private Hash() {}\n", "    public static Hash getInstance() {\n", "        if (instance == null) {\n", "            instance = new Hash();\n", "        }\n", "        return instance;\n", "    }\n", " \n", "    public void initHashKeys() {\n", "        for (int i = 0; i < 13 * 120; i++) {\n", "            pieceKeys[i] = Board.random();\n", "        }\n", "        sideKey = Board.random();\n", "        for (int i = 0; i < 16; i++) {\n", "            castleKey[i] = Board.random();\n", "        }\n", "    }\n", "```\n", "\n", "This is fairly simple, we just put a random number for every slot in all the arrays. Moving on to the actual key generation:\n", "\n", "```\n", "public int generatePosKey() {\n", "        int finalKey = 0;\n", "        for (int sq = 0; sq < Board.NUM_SQ; sq++) {\n", "            int piece = Board.getInstance().pieces[sq];\n", "            if (piece != Piece.EMPTY && piece != Squares.OFFBOARD) {\n", "                finalKey ^= pieceKeys[(piece * 120) + sq];\n", "            }\n", "        }\n", "        if (Board.getInstance().side == Color.WHITE) {\n", "            finalKey ^= sideKey;\n", "        }\n", " \n", "        if (Board.getInstance().enPassantSquare != Squares.NOSQ) {\n", "            finalKey ^= pieceKeys[Board.getInstance().enPassantSquare];\n", "        }\n", "        finalKey ^= castleKey[Board.getInstance().castlePerms];\n", "        return finalKey;\n", "    }\n", "\n", "```\n", "\n", "Ok, here we iterate through all of the squares on the board (including the sentinels) and if there is a piece on that square and it is not a sentinel square we get the corresponding random number from our previously generated pieceKeys[]  array and XOR it with the hash key. Remember we laid our our pieceKeys[]  array by piece type and 120 slots for each piece type. So we can access it by multiplying the piece integer value with 120 and adding the square. We incorporate the side to move into the key if it\u2019s white or skip it for black. If the en passant square is set we also XOR that into our key. We could have also accessed the pieceKeys[]  like this for en passant pieceKeys[Piece.EMPTY * 120 + sq]  but Piece.EMTPY is zero so we can leave it out.\n", "\n", "We can also add some tests to verify that our initialization and generation are working as expected\n", "\n", "\n", "```\n", "@Test\n", "    public void shouldInitHashKeys() {\n", "        Hash.getInstance().initHashKeys();\n", "        for (int i = 0; i < 13 * 120; i++) {\n", "            int pieceKey = Hash.getInstance().pieceKeys[i];\n", "            assertTrue(pieceKey != 0);\n", "        }\n", "        assertTrue(Hash.getInstance().sideKey != 0);\n", "        for (int i = 0; i < 16; i++) {\n", "            assertTrue(Hash.getInstance().castleKey[i] != 0);\n", "        }\n", "    }\n", " \n", "    @Test\n", "    public void shouldGeneratePosKey() {\n", "        Board.getInstance().pieces[21] = Piece.wP;\n", "        Hash.getInstance().initHashKeys();\n", "        int key = Hash.getInstance().generatePosKey();\n", "        assertTrue(key != 0);\n", "    }\n", "\n", "```\n"]}], "metadata": {"celltoolbar": "Tags", "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.13"}}, "nbformat": 4, "nbformat_minor": 4}
        </script>
    </head>
    <body>
        <div id="main">
            <div class="header">
            <div style="position: absolute; left:10px; top:5px;">
              <a href="/blog/about.html">about</a>
              <!--a href="/micro/micro.html">micro</a-->
              <a href="/blogindex.html">micro</a>
            </div>
            <h1>Deniz's Webblog</h1>
            <p style="font-family: monospace;">
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
            </p>
            </div>
            <div id="notebook-holder"></div>
            <hr/>
            <div>
              <em>Generated on 2021-07-21 17:16:06</em>
            </div>
            <p>
              Questions or comments? Please take the time to compose an email and send it to <a href="mailto:deniz.dizman@gmail.com?subject=Question/Comment">me</a>.
              I will update the relevant page with our correspondence.
            </p>
        </div>
        <script>
          var src = document.getElementById("source");
          var notebook = nb.parse(JSON.parse(src.innerText));
          var rendered = notebook.render();
          document.getElementById("notebook-holder").appendChild(rendered);
        </script>
    </body>
</html>
