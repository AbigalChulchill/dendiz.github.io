<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Deniz's personal pages</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <script src="/js/vendor/es5-shim.min.js"></script>
        <script src="/js/vendor/marked.min.js"></script>
        <!--script src="/js/vendor/purify.min.js"></script-->
        <script src="/js/vendor/ansi_up.min.js"></script>
        <script src="/js/vendor/prism.min.js"></script>
        <script src="/js/vendor/katex.min.js"></script>
        <script src="/js/vendor/katex-auto-render.min.js"></script>
	<script src="/js/vendor/notebook.js?_=2021-09-02 09:46:04"></script>
        <link rel="stylesheet" href="/css/vendor/katex.min.css" />
        <link rel="stylesheet" href="/css/vendor/prism.css" />
	<link rel="stylesheet" href="/css/notebook.css?2021-09-02 09:46:04" />
	<link rel="stylesheet" href="/css/nbpreview.css?2021-09-02 09:46:04" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet">
        <script type="application/text" id="source">
          {"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# 3 different approaches to the same problem\n", "", "2018-05-09t23:08:34-07:00 [#programming](/tag/programming.html)\n"]}, {"cell_type": "markdown", "metadata": {"tags": ["programming"]}, "source": ["\n", "\n", "I came a across a seemingly simple problem today that turned out to have multiple solutions with varying efficiency. These type of problems are very well suited for step by step iterative solutions where each step you improve upon the existing solution. \n", "The problem is the simple matter of find the first unique character in a string. \n", "I'm skipping the obvious solution of starting at the beginning of the string and scanning through the string comparing the current charater with every other. This type of solution will lead to an N^2 solution which is usually unacceptable. Think that you are searching a DNA sequence of 10 million nucleotides. No way exponential solutions are going to work. \n", "So the first solution is this:\n", "\n", "1. scan the list from left, and keep track of the characters and the number of times we have seen a character. \n", "2. scan the list from left and lookup the number of times the current character was seen. If it's 1 then we've found the first non-repeating character.\n", "\n", "```\n", "Character findFirstUniqWorst(String s) {\n", "        HashMap<Character, Integer> map = new HashMap<>();\n", "        for (char c : s.toCharArray()) {\n", "            if (!map.containsKey(c)) {\n", "                map.put(c, 0);\n", "            }\n", "            int e = map.get(c);\n", "            map.put(c, e + 1);\n", "        }\n", "\n", "        for (char c: s.toCharArray()) {\n", "            if (map.get(c) == 1) {\n", "\n", "                return c;\n", "            }\n", "        }\n", "\n", "        throw new RuntimeException();\n", "    }\n", "\n", "```\n", "\n", "an improvement on this would be to eliminate the 2nd scan. If we stored the position of the 1st occurance of a character with the count we could return that. Something like: \n", "\n", "1. scan the list from the left and build the count map. Store the position of the first occurance too like 'a'->(count, position) \n", "2. scan the map and return the result with count equal to 1 having to lowest position.\n", "\n", "```\n", "static class Pair {\n", "        public int count;\n", "        public int position;\n", "\n", "        public Pair(int count, int position) {\n", "            this.count = count;\n", "            this.position = position;\n", "        }\n", "    }\n", "    Character findFirstUniqMed(String s) {\n", "        HashMap<Character, Pair> map = new HashMap<>();\n", "        char[] chars = s.toCharArray();\n", "        for (int i=0;i<chars.length;i++) {\n", "            char c = chars[i];\n", "            if (!map.containsKey(c)) {\n", "                map.put(c, new Pair(1, i));\n", "            } else {\n", "                Pair e = map.get(c);\n", "                e.count += 1;\n", "                map.put(c, e);\n", "            }\n", "        }\n", "        int index = Integer.MAX_VALUE;\n", "        Character returnChar = null;\n", "        for (Character c : map.keySet()) {\n", "            if (map.get(c).count == 1) {\n", "                if (map.get(c).position < index) {\n", "                    returnChar = c;\n", "                }\n", "            }\n", "        }\n", "        return returnChar;\n", "    }\n", "```\n", "\n", "this is a good option if the alphabet is small like in the DNA example. But if the alphabet is large, we still would do a large scan. So enter the third option: \n", "instead of keeping the position of the character, keep a pointer to a linked list node. This linkedlist will hold the the unique characters we've seen so far and the head of the link list will be the first. \n", "\n", "1. scan the list from the left. \n", "     1. if the character is not in the map, insert a node to the tail of the list and add the (char->node) mapping \n", "     2. if the characater is in the map, and pointer to a node exists remove the node from the link delete, set (char->null) as the mapping \n", "     3. if the character is in the map and the pointer doesn't exists do nothing and continue with the next. \n", "\t \n", "this method will scan the input string once but return the first found character o(1).\n", "\n", "```\n", "static class DoubleLinkedList {\n", "        public Character value;\n", "        public DoubleLinkedList prev;\n", "        public DoubleLinkedList next;\n", "    }\n", "    Character findFirstUniqBest(String s) {\n", "        char[] chars = s.toCharArray();\n", "        DoubleLinkedList list = new DoubleLinkedList();\n", "        HashMap<Character, DoubleLinkedList> map = new HashMap<>();\n", "        DoubleLinkedList head, tail;\n", "        head = list;\n", "        tail = list;\n", "        for (int i = 0; i < chars.length; i++) {\n", "            char cur = chars[i];\n", "            if (!map.containsKey(cur)) {\n", "                DoubleLinkedList node = new DoubleLinkedList();\n", "                node.value = cur;\n", "                node.prev = tail;\n", "                node.next = null;\n", "                tail.next = node;\n", "                map.put(cur, node);\n", "                tail = node;\n", "            } else {\n", "                if (map.get(cur) != null) {\n", "                    if (map.get(cur).prev == null) {\n", "                        head = map.get(cur).next;\n", "                    } else {\n", "                        map.get(cur).prev.next = map.get(cur).next;\n", "                    }\n", "                    if (map.get(cur).next == null) {\n", "                        map.get(cur).prev.next=null;\n", "                        tail = map.get(cur).prev;\n", "                    } else {\n", "                        map.get(cur).next.prev = map.get(cur).prev;\n", "                    }\n", "                    map.put(cur, null);\n", "                }\n", "            }\n", "        }\n", "        if (head == null) throw new RuntimeException();\n", "        return head.value == null ? head.next.value : head.value;\n", "    }\n", "```\n"]}], "metadata": {"celltoolbar": "Tags", "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.12"}}, "nbformat": 4, "nbformat_minor": 4}
        </script>
    </head>
    <body>
        <div id="main">
            <div class="header">
            <div style="position: absolute; left:10px; top:5px;">
              <a href="/blog/about.html">about</a>
              <a href="/micro/micro.html">micro</a>
              <a href="/blogindex.html">macro</a>
            </div>
            <h1>Deniz's Weblog</h1>
            <p style="font-family: monospace;">
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
            </p>
            </div>
            <div id="notebook-holder"></div>
            <hr/>
            <div>
              <em>Generated on 2021-09-02 09:46:04</em>
            </div>
            <p>
              Questions or comments? Please take the time to compose an email and send it to <a href="mailto:deniz.dizman@gmail.com?subject=Question/Comment">me</a>.
              I will update the relevant page with our correspondence.
            </p>
        </div>
        <script>
          var src = document.getElementById("source");
          var notebook = nb.parse(JSON.parse(src.innerText));
          var rendered = notebook.render();
          document.getElementById("notebook-holder").appendChild(rendered);
        </script>
    </body>
</html>
