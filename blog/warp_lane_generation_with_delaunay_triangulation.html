<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Deniz's personal pages</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <script src="/js/vendor/es5-shim.min.js"></script>
        <script src="/js/vendor/marked.min.js"></script>
        <!--script src="/js/vendor/purify.min.js"></script-->
        <script src="/js/vendor/ansi_up.min.js"></script>
        <script src="/js/vendor/prism.min.js"></script>
        <script src="/js/vendor/katex.min.js"></script>
        <script src="/js/vendor/katex-auto-render.min.js"></script>
	<script src="/js/vendor/notebook.js?_=2021-08-03 23:38:03"></script>
        <link rel="stylesheet" href="/css/vendor/katex.min.css" />
        <link rel="stylesheet" href="/css/vendor/prism.css" />
	<link rel="stylesheet" href="/css/notebook.css?2021-08-03 23:38:03" />
	<link rel="stylesheet" href="/css/nbpreview.css?2021-08-03 23:38:03" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet">
        <script type="application/text" id="source">
          {"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# warp lane generation with delaunay triangulation\n", "", "2017-09-17 [#gamedev](/tag/gamedev.html)\n"]}, {"cell_type": "markdown", "metadata": {"tags": ["gamedev"]}, "source": ["\n", "Hyper lanes a.k.a Warp Lanes? What are those? They are a simple element of most space RTS/TBS games. They the lines that connect the stars. They are the highway lanes of space time, they enable spaceships to travel through them and guide the spaceships to their destination. They are a cheap alternative to wormhole generators which bend space time to connect stars. Here are what they look like from a popular game\n", "\n", "![](/img/wlg1.png)\n", "\n", "Technically speaking they are edges (the lines) between vertices (stars). What we need to do is generate these edges given a set of vertices and there a couple of methods for doing this. The first one that pops up is to generate a minimum spanning tree. But a minimum spanning tree would look this\n", "\n", "![](/img/wlg2.png)\n", "\n", "and this doesn\u2019t exactly look like a nice interstellar highway as we would like to be able to travel to a couple of nearby stars from our origin star. This way when we are trying to reach a distant star we have multiple options of getting to that star. Image that you did your warplanes using an MST and you want to get from star A to star D and the only path is A -> B -> C -> D. What do you do if there is an enemy fleet in the star C system and you don\u2019t want to engage that fleet with your science ship? Observe that the MST has only 1 connection between 2 neighboring stars so there is no way for you to do that.\n", "\n", "So here is a naive algorithm I came up with\n", "\n", "1. let S be a list star with random coordinates in a 1000\u00d71000 plane\n", "1. for each star in S\n", "    1. if a star was visited before, skip it\n", "    1. get the N closest stars to this star\n", "    1. add a connection from this star to its neighbors\n", "    1. add a connection from each neighbor to this star the get closest star also needs some attention as we don\u2019t want to return a close neighbor if it already has a connection to the current star.\n", "\n", "the get closest star also needs some attention as we don\u2019t want to return a close neighbor if it already has a connection to the current star.\n", "\n", "1. filter out all other stars except our current star\n", "1. filter out all stars that already have a connection with the current star\n", "1. map the remaining stars as a tuple of ( distance to source, this star)\n", "1. sort by the distance\n", "1. take N closest and return the stars from the tuple\n", "\n", "\n", "The N parameter determines the number of max connections going out from a star. Here is an image of this algorithm with N=5\n", "\n", "\n", "![](/img/wlg3.png)\n", "\n", "\n", "This does look a bit better but there are too many cramped points where it\u2019s hard to tell what\u2019s going on. The stars are too close to each other so we need some kind of regulation when generating the random points for the stars. One way of doing this is checking the \u201cstar density\u201d when generating the star and only placing the star if it\u2019s acceptable. This basically means not placing a star to close another and we can do this by checking if the generated star falls within a range of existing stars. That would be done by checking if it lies in a circle of radius R with the star at its origin.\n", "\n", "1. let S be a list of stars initially empty\n", "1. while S size < number of stars to generate\n", "1. generate a random point in the plane\n", "1. if this point satisfies the density condition add the star to S\n", "\n", "\n", "One point to note about this algorithm is that it has the possibility of never terminating if the density conditions are too strict and it cannot find a good place for the next star. So it\u2019s a good idea to add a loop counter check that will terminate with an exception after a number of tries and tell the user to relax the number of stars and the radius R. The acceptable density function can be done as follows\n", "\n", "\n", "1. let R be the minimum distance that two stars should be apart (which is the radius R)\n", "1. for each star already generated check if (src.x \u2013 star.x)^2 \u2013 (src.y \u2013 star.y)^2 < R^2\n", "1. if there are stars that satisfy this equation then the density condition is not satisfied.\n", "\n", "\n", "After adding the density check and reducing N to 3 the lines look a bit clearer.\n", "\n", "![](/img/wlg4.png)\n", "\n", "\n", "There is a fundamental error in this approach. If you select a low N (connectivity value) then you sometimes will get disconnected stars like this\n", "\n", "![](/img/wlg5.png)\n", "\n", "\n", "To address this issue a combination of an MST and the naive approach could work.\n", "\n", "![](/img/wlg6.png)\n", "\n", "\n", "Now that the MST guarantees that all the graph will be connected we have addressed the issue but still, the layout doesn\u2019t look good for efficient traveling. We still could use more triangulation that is more lanes connecting nearby stars. Using the closest N method led to a cluttered layout. The cause of this clutter is that if 2 stars are almost in a straight line and are the 2 closest stars, there will 2 connections to these stars that overlap.\n", "\n", "![](/img/wlg7.png)\n", "\n", "\n", "Yet another way of connecting the stars would be to use Delaunay Triangulation. This also produces a very nice warplane structure but still, has the cluttering problem due to the star layout.\n", "\n", "![](/img/wlg8.png)\n", "\n", "Now let\u2019s address the clutter problem. It seems that the warplanes look cluttered if there are neighboring stars too close to an existing warplane.\n", "\n", "![](/img/wlg9.png)\n", "\n", "\n", "the green arrow shows a lane we could do better without. How can we detect these lanes? Just from the definition of the problem. If a neighbor star is too close to a lane, drop the existing lane so the closer lane to the a star will remain. Here is a simple outline for the algorithm that requires a bit of linear algebra:\n", "\n", "1. Sort all the neighbors for each star is descending order according to their distance from the origin star.\n", "1. for each neighbor i to all neighbors \u2013 1\n", "    1. for each neighbor j from i + 1 to all neighbors\n", "    1. if the distance of neighbor i from the lane between origin star and neighbor j < some threshold T discard the lane calculating the distance of a point P0 to a line given by P1 and P2 is\n", "\n", "`Math.abs( (y2-y1)x0 \u2013 (x2-x1)y0 + x2y1 \u2013 y2x1 ) / Math.sqrt( Math.pow(y2-y1,2) + Math.pow(x2-x1,2) )`\n", "\n", "Here is the result of a relaxed threshold that will draw a lot of lines\n", "\n", "![](/img/wlg10.png)\n", "\n", "here are the same results with a stricter threshold that has discarded the middle lane\n", "\n", "![](/img/wlg10.png)\n", "\n"]}], "metadata": {"celltoolbar": "Tags", "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.12"}}, "nbformat": 4, "nbformat_minor": 4}
        </script>
    </head>
    <body>
        <div id="main">
            <div class="header">
            <div style="position: absolute; left:10px; top:5px;">
              <a href="/blog/about.html">about</a>
              <a href="/micro/micro.html">micro</a>
              <a href="/blogindex.html">macro</a>
            </div>
            <h1>Deniz's Weblog</h1>
            <p style="font-family: monospace;">
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
            </p>
            </div>
            <div id="notebook-holder"></div>
            <hr/>
            <div>
              <em>Generated on 2021-08-03 23:38:03</em>
            </div>
            <p>
              Questions or comments? Please take the time to compose an email and send it to <a href="mailto:deniz.dizman@gmail.com?subject=Question/Comment">me</a>.
              I will update the relevant page with our correspondence.
            </p>
        </div>
        <script>
          var src = document.getElementById("source");
          var notebook = nb.parse(JSON.parse(src.innerText));
          var rendered = notebook.render();
          document.getElementById("notebook-holder").appendChild(rendered);
        </script>
    </body>
</html>
