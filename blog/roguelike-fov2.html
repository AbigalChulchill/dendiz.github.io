<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Deniz's personal pages</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <script src="/js/vendor/es5-shim.min.js"></script>
        <script src="/js/vendor/marked.min.js"></script>
        <!--script src="/js/vendor/purify.min.js"></script-->
        <script src="/js/vendor/ansi_up.min.js"></script>
        <script src="/js/vendor/prism.min.js"></script>
        <script src="/js/vendor/katex.min.js"></script>
        <script src="/js/vendor/katex-auto-render.min.js"></script>
	<script src="/js/vendor/notebook.js?_=2021-09-09 18:50:32"></script>
        <link rel="stylesheet" href="/css/vendor/katex.min.css" />
        <link rel="stylesheet" href="/css/vendor/prism.css" />
	<link rel="stylesheet" href="/css/notebook.css?2021-09-09 18:50:32" />
	<link rel="stylesheet" href="/css/nbpreview.css?2021-09-09 18:50:32" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet">
        <script type="application/text" id="source">
          {"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# roguelike fov 2\n", "", "2020-07-18t13:37:00-07:00 [#programming](/tag/programming.html) [#gamedev](/tag/gamedev.html)\n"]}, {"cell_type": "markdown", "metadata": {"tags": ["programming", "gamedev"]}, "source": ["# Shadow casting\n", "\n", "I was thinking that the ray casting method above would be sufficient but I have since seen some quirks in the highlighted tiles in the FoV that made me want to ditch it. Another reason for implementing a more efficient algorithm is that the enemies and neutral characters in the level also have a field of view that will make them react to other actors, props, etc. that they can see. This meant that the FoV calculations will be triggered over and over for potentially tens to hundreds of actors per turn.\n", "\n", "Shadow casting is actually a reversal in a sense that you don't try to figure out the cells that are visible but try to find the cells that are shadowed by obstacles. After some research on previous implementations I was able to grasp the logic behind the algorithm and want to go over it here with hopes to explain it better.\n", "\n", "Ultimately we want to have a 360 degree FoV but breaking up the whole into 8 pieces of 45 degrees each will make it much more simpler as the algorithm is basically the same for each octant with just the increments of the rows and columns differing by octant.\n", "\n", "```\n", "#################f\n", "#.......11111...#e\n", "#.......1111....#d\n", "#.......111.....#c\n", "#.......11......#b\n", "#.......@.......#a\n", "#...............#\n", "#################\n", "```\n", "\n", "*the first octant marked by 1's*\n", "\n", "we will scan each row in the octant and mark it as visible if there is no object that is cast a shadow, starting for row a working out way up to row f. You should terminate processing if the FoV radius is reached before the end of the map. So without any blocking tiles this is rather straight forward.\n", "\n", "```\n", "for row in 1..<actor.fovRadius {\n", " for col in 0...row {\n", "   y = player.position.y - row\n", "   x = player.position.x + col\n", "   map[y][x] = 1\n", " }\n", "}\n", "```\n", "\n", "Then we need to repeat the same for the remaining 7 octants. The part that will change is the player.position.y - row and player.position.x + col. For the octant that covers [-45;0] you would want to subtract the column instead of adding it. A nice way of implementing this would be to store the increment deltas in a list and apply them based on the octant number\n", "\n", "```\n", "let octants = [\n", " [XY(x: 0, y: -1), XY(x: 1, y: 0)],\n", " [XY(x: 1, y: 0), XY(x: 0, y: -1)],\n", " [XY(x: 1, y: 0), XY(x: 0, y: 1)],\n", " [XY(x: 0, y: 1), XY(x: 1, y: 0)],\n", " [XY(x: 0, y: 1), XY(x: -1, y: 0)],\n", " [XY(x: -1, y: 0), XY(x: 0, y: 1)],\n", " [XY(x: -1, y: 0), XY(x: 0, y: -1)],\n", " [XY(x: 0, y: -1), XY(x: -1, y: 0)]\n", "]\n", "```\n", "\n", "Now the increments can be accessed as\n", "\n", "```\n", "let rowInc = octants[octant][0]\n", "let colInc = octants[octant][1]\n", "and we can iterate over this list for each octant we want to process\n", "let fov = (0..<8).flatMap { processOctant(actor: actor, octant: $0) }\n", "with the\n", "private func processOctant(actor: Character, octant: Int) -> [XY] {\n", "...\n", "}\n", "```\n", "\n", "Ok, so how can we calculate the shadows? The idea is to keep a list of shadow angles that are being cast from an opaque object. We'll define the angle to be a value between 0 and 1 where 0 represents 0 degrees and 1 represents 45 degrees in the first octant. This will have different values for the other octants but that's not important. We're not really dealing with the angles but the slope of the ray that touches from the top left of the obstacle and the bottom right proceeding upwards and right (for the 1st octant) that is originating from the player.\n", "\n", "\n", "\n", "Here's a zoomed in version\n", "\n", "*light rays shooting from the player*\n", "\n", "Any tile that has a projection (lights shooting from the player touch the top left and bottom right) that falls within the range of already calculated projections cannot be seen by the player. This is due to the fact that any tile further away from the player will have a narrower angle between the left and right slopes because all of the tiles are the same size and shape.\n", "\n", "Calculating the slopes for the projection is basically finding the ratio of the columns to rows of the top left and bottom right parts of the tile. By rows and columns I mean the length of the line from the player tile to the target tile.\n", "\n", "```\n", "private func getProjection(row: Int, col: Int) -> Shadow {\n", "    let topLeft = Double(col) / Double(row + 1)\n", "    let bottomRight = Double(col + 1) / Double(row)\n", "    return Shadow(start: topLeft, end: bottomRight)\n", "}\n", "```\n", "\n", "for the lop left calculation the nominator is col as the player location is zero so target location - player location is just the column of the target. The denominator has 1 added to its row because the it's actually the bottom of the row above it. For the bottom right calculation we need to add 1 to the column as it's actually the corner of the next column.\n", "\n", "As we are processing row by row we need to keep track of all the shadows (left and right slopes) to filter out tiles that fall into this range. We could keep a list of all the left/right slopes we have seen thus far and linearly search each one but there is a better way: we can actually merge any new projections that we encounter into a list of existing projections. This works like this:\n", "\n", "Let's say our shadow list is\n", "\n", "[(0...0.2), (0.6...0.7)]\n", "\n", "and we get the projection (0.8...0.9). We check out list and see that it doesn't intersect with any existing projections so we can just append it to our list. Out new list is\n", "\n", "[(0...0.2), (0.6...0.7), (0.8...0.9)].\n", "\n", "Lets say our next tile has the projection [0.4...0.85]. This fits right into the middle of and covers the existing (0.6...0.7) projection entirely and also partially covers (0.8...0.9) so we can go ahead and merge. Our new list is now\n", "\n", "[(0...0.2), (0.4...0.9)]\n", "\n", "Instead of having 4 items we have 2 now that we merged. If we ever reach a state where we have only one element in the shadows list and the left slope is 0 and right slope is 1 then we have the whole octant covered and every object in the rows after this row will be covered by the shadow so we can stop processing.\n", "\n", "```\n", "private func processOctant(actor: Character, octant: Int) -> [XY] {\n", "    let rowInc = octants[octant][0]\n", "    let colInc = octants[octant][1]\n", "    var fullShadow = false\n", "    var result = [XY]()\n", "    shadows = [Shadow]()\n", "    for row in 1..<actor.fovRadius {\n", "        var pos = actor.location + (rowInc * row)\n", "        guard actor.game.scene.viewPort.contains(point: pos) else { break }\n", "        for col in 0...row {\n", "            if fullShadow {\n", "                continue\n", "            } else {\n", "                let projection = getProjection(row: row, col: col)\n", "                if !isInShadow(projection: projection) {\n", "                    result.append(pos)\n", "                }\n", "                if actor.game.level.map[pos.y][pos.x].blocking {\n", "                    fullShadow = addShadow(shadow: projection)\n", "                }\n", "            }\n", "            pos = pos + colInc\n", "            guard actor.game.scene.viewPort.contains(point: pos) else { break }\n", "        }\n", "    }\n", "    return result\n", "}\n", "```\n", "\n", "So how would this merging algorithm look like? Here are the steps we need to consider\n", "\n", "1. Find out the correct index to put our new item in. It could be with or without a merge.\n", "2. Find if our new item overlaps with the previous entry or the next entry. We'll use this to do any necessary merges.\n", "3. handle the 4 conditions of\n", "   1. overlaps with previous and next\n", "   2. overlaps with next but not previous\n", "   3. overlaps with previous but not next\n", "   4. there is no overlap at all\n", "   5. based on the overlapping situation adjusting the start/end (left/right) slope will take care of the merging.\n", "\n", "```\n", "var index = 0\n", " for curShadow in shadows {\n", "     if curShadow.start > shadow.start {\n", "         break\n", "     }\n", "     index += 1\n", " }\n", " //let index = shadows.firstIndex { $0.start > shadow.start } ?? shadows.count\n", " \n", " let overlapsPrev = (index > 0) && (shadows[index - 1].end > shadow.start)\n", " let overlapsNext = (index < shadows.count) && shadows[index].start < shadow.end\n", " \n", " if overlapsNext {\n", "     if overlapsPrev {\n", "         shadows[index - 1].end = max(shadows[index-1].end, shadows[index].end)\n", "         shadows.remove(at: index)\n", "     } else {\n", "         shadows[index].start = min(shadows[index].start, shadow.start)\n", "     }\n", " } else {\n", "     if overlapsPrev {\n", "         shadows[index - 1].end = max(shadows[index - 1].end, shadow.end)\n", "     } else {\n", "         shadows.insert(shadow, at: index)\n", "     }\n", " }\n", "```\n", "\n", "Here are 2 images of a ray casting and shadow casting to compare:\n", "\n", "\n", "\n", "\n"]}], "metadata": {"celltoolbar": "Tags", "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.13"}}, "nbformat": 4, "nbformat_minor": 4}
        </script>
    </head>
    <body>
        <div id="main">
            <div class="header">
            <div style="position: absolute; left:10px; top:5px;">
              <a href="/blog/about.html?2021-09-09 18:50:32">about</a>
              <a href="/micro/micro.html?2021-09-09 18:50:32">micro</a>
              <a href="/blogindex.html?2021-09-09 18:50:32">macro</a>
            </div>
            <h1>Deniz's Weblog</h1>
            <p style="font-family: monospace;">
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
            </p>
            </div>
            <div id="notebook-holder"></div>
            <hr/>
            <div>
              <em>Generated on 2021-09-09 18:50:32</em>
            </div>
            <p>
              Questions or comments? Please take the time to compose an email and send it to <a href="mailto:deniz.dizman@gmail.com?subject=Question/Comment">me</a>.
              I will update the relevant page with our correspondence.
            </p>
        </div>
        <script>
          var src = document.getElementById("source");
          var notebook = nb.parse(JSON.parse(src.innerText));
          var rendered = notebook.render();
          document.getElementById("notebook-holder").appendChild(rendered);
        </script>
    </body>
</html>
