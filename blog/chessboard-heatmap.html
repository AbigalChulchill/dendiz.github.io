<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Deniz's personal pages</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <script src="/js/vendor/es5-shim.min.js"></script>
        <script src="/js/vendor/marked.min.js"></script>
        <!--script src="/js/vendor/purify.min.js"></script-->
        <script src="/js/vendor/ansi_up.min.js"></script>
        <script src="/js/vendor/prism.min.js"></script>
        <script src="/js/vendor/katex.min.js"></script>
        <script src="/js/vendor/katex-auto-render.min.js"></script>
	<script src="/js/vendor/notebook.js?_=2021-08-22 11:26:49"></script>
        <link rel="stylesheet" href="/css/vendor/katex.min.css" />
        <link rel="stylesheet" href="/css/vendor/prism.css" />
	<link rel="stylesheet" href="/css/notebook.css?2021-08-22 11:26:49" />
	<link rel="stylesheet" href="/css/nbpreview.css?2021-08-22 11:26:49" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet">
        <script type="application/text" id="source">
          {"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# chessboard heat map\n", "", "2015-09-20 [#programming](/tag/programming.html) [#chess](/tag/chess.html)\n"]}, {"cell_type": "markdown", "metadata": {"tags": ["programming", "chess"]}, "source": ["The apache spark framework is a great way of processing HUGE amounts of data in parallel. The learning curve is really flat, and you\u2019ll get to crunching data in no time. I have already implemented a batch log processing / analytics application and a real-time streaming application at work for n11 and I thought that I do another fun project with spark. This time it\u2019s generating a heat-map of a chess board by processing chess games. A heat map of a chess board is 8\u00d78 table with each cell representing a square of the chess board with a color. Blue means there were not many moves to that square, and red means there were a lot. It\u2019s an analogy to the warm-cold method of defining distance. We will do this for each piece there is in chess. The end results will look something like this\n", "\n", "\n", "![](http://i.imgur.com/6hGU74G.png)\n", "\n", "So, a method we could use and that I\u2019ve tried was to generate a FEN representation of the board after each move, and feed this data to apache spark to extract how much each piece occupied each square. This did sound reasonable and it would have been very efficient because spark would not need any chess knowledge to compute the heat map. Just some string parsing would suffice. But it turns out that this method of processing overwhelms the heat map with the initial positions of the piece. Why? because the pieces rest on their initial squares for quite some time before they move. Let\u2019s look at an example to make it clearer. The initial state of the board as a FEN string is:\n", "\n", "`rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR`\n", "\n", "this would mean add 1 to the squares for each piece. E.g the rooks are on a1, a8, h1, h8. Add 1 to each square. After the first move, say 1. e4, the FEN is\n", "\n", "`rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR`\n", "\n", "The pawn will register a hit for the e4 square, but so will all the other remaining pieces for their home squares! The will generate a heat map that says all the pieces like their home squares best which isn\u2019t really helpful.\n", "\n", "So we need another approach. The best way is to register a square that a piece has moved to. This requires parsing the moves in the PGN game and actually playing through the game. So we need a chess parsing library to use in our spark job. Fortunately I had a nifty little port of chess.js for java handy here that would allow me to play through the games and get back the squares the pieces moved to. But before we can dive into this, we need to clean the PGN files and make them suitable for processing by Spark. Data processing platforms like spark like to munch data that are in CSV format \u2013 a line of values separated by a comma. The values in our file will be the moves from each game, starting from the initial position. Here is an example of what I mean\n", "\n", "\n", "```\n", "d4,Nf6,c4,e6,Nf3,d5,Nc3,Be7,Bg5,h6,Bh4,O-O,e3,b6,Bd3,Bb7,\n", "O-O,Nbd7,Bg3,c5,cxd5,Nxd5,Nxd5,Bxd5,Rc1,Nf6,dxc5,Bxc5,a3,a5,\n", "Qe2,Nh5,Be5,Bxf3,gxf3,Qg5+,Bg3,g6,Rc4,Rfd8,Rd1,Rd5,Rg4,Nxg3,\n", "hxg3,Qf6,Rf4,Qg5,Rg4,Qf6,Rf4,Qg5,Rg4,Qf6\n", "e4,c5,Nf3,d6,d4,cxd4,Nxd4,Nf6,Nc3,a6,g3,e6,Bg2,Be7,O-O,O-O,a4,\n", "Nc6,Be3,Rb8,f4,Qc7,Kh1,Bd7,Nb3,b6,g4,h6,Qe2,Nb4,Nd4,Rbc8,\n", "Rad1,Qc4,Qf3,e5,Nf5,Bxf5,exf5,exf4,Rd4,Qc7,Bxf4,Nxc2,Rd2,Nb4,h4,\n", "Nh7,g5,Qc4,f6,gxf6,gxf6,Bxf6,Ne4,Be5,Rxd6,Bg7,Bxh6,Bxh6,Rxh6,Rc6,Qg4+,Kh8,Rxh7+\n", "```\n", "\n", "So let\u2019s dive into converting the PGN files.We will use the excellent chesspresso library to parse the PGN files because I haven\u2019t yet integrated PGN methods into chesslib. the dependency for chesspresso can be added using\n", "\n", "\n", "```\n", "resolvers += \"clojars.org\" at \"http://clojars.org/repo\"\n", "libraryDependencies += \"com._0xab\" % \"chesspresso\" % \"0.9.2\"\n", "```\n", "\n", "\n", "Thanks to the guy who was kind enough to package and upload this to a repository. Meanwhile I\u2019m not so nice and haven\u2019t uploaded chesslib to a repository, but no problem we\u2019ll just add it to the /lib directory and the sbt assembly plugin will pick it up from there. So let\u2019s start by parsing the PGN files using chesspresso\n", "\n", "\n", "```\n", "def getGames(file: File) : Stream[Game] = {\n", "    val fis = new FileInputStream(file)\n", "    println(\"parsing file \" + file)\n", "    val reader = new PGNReader(fis, \"\")\n", " \n", "    val games = di2(reader)\n", "    //println(file + \"... found \" + games.size + \" games\")\n", " \n", "    games\n", "  }\n", "\n", "```\n", "\n", "\n", "this method expects the PGN file as a File object, and reads it using the chesspresso PGNReader.\n", "\n", "\n", "```\n", "def di2(reader:PGNReader): Stream[Game] = {\n", "    @tailrec\n", "    def di3(game:Game, reader:PGNReader, gameList : Stream[Game]): Stream[Game] = {\n", "      if (Option(game).isDefined) {\n", "        if (gameList.size % 5000 == 0) {\n", "          println(\"processing game \" +gameList.size + \" \" + game)\n", "        }\n", "        //println(\"found game \" + game + \" list size \" +gameList.size )\n", "        di3(try {reader.parseGame()} catch{ case e:Exception=&gt;reader.parseGame()},reader, game #:: gameList)\n", "      } else {\n", "        gameList\n", "      }\n", "    }\n", "    di3(reader.parseGame(), reader, Stream.empty)\n", "  }\n", "\n", "```\n", "\n", "\n", "this is the actual method that reads the games to a list. Chesspresso iterates over the games and streams the games from the file on demand (because PGN files may contain more than one game). Since we are consuming the whole stream this will not work if you try to process a PGN file with lots of games in it (around 1M suffers on my 8gb machine). If you need to split a PGN file to smaller files use pgn-extract.\n", "\n", "\n", "```\n", " def extractMoves(game:Game) : String = {\n", "    game.gotoStart()\n", "    try {\n", "      val mainLine = game.getMainLine.toSeq\n", "      val moves = mainLine.map(x=> {\n", "        game.getPosition.doMove(x)\n", "        x\n", "      }).toList.filter(_ != &quot;&quot;)\n", "      moves.mkString(&quot;,&quot;)\n", "    } catch {\n", "      case e:Exception=>\"\"\n", "    }\n", "  }\n", "```\n", "\n", "This method will get the moves made in the game as a list and concatenate them using a comma to the CSV format that I showed you above. Chesspresso will throw an exception on an invalid move, and some PGN\u2019s do contain invalid moves.\n", "\n", "\n", "```\n", " def main(args:Array[String]) = {\n", "    val hotFolder = \"/data/pgn/archive/\"\n", "    val outFolder = \"/data/fen/\"\n", "    val files: Seq[File] = new File(hotFolder).listFiles().toSeq.filter(_.getName.endsWith(\"pgn\"))\n", " \n", "    files.foreach({file=>\n", "      val games = getGames(file)\n", "      val moves = games.map(extractMoves)\n", "      val target = new BufferedOutputStream( new FileOutputStream(new File(outFolder+file.getName + \".moves\")) )\n", "      try moves.foreach({x=> target.write(x.getBytes); target.write(\"n\".getBytes) }) finally target.close\n", "    })\n", "  }\n", "\n", "```\n", "\n", "All that\u2019s left is to execute the parsing methods and save the CSV move list to a file and we are ready to jump into spark to process this data. Thats what the main function above does.\n", "\n", "So let\u2019s define some spark configs like the CSV file location etc.\n", "\n", "```\n", "val logFile = \"/data/fen/\" // Should be some file on your system\n", "val outputDir = \"/tmp/\"\n", "val conf = new SparkConf().setAppName(\"Simple Application\")\n", "val sc = new SparkContext(conf)\n", "val moveData = sc.textFile(logFile)\n", "```\n", "\n", "\n", "we will also need a data structure to hold the results, how many times each piece moves to a square.\n", "\n", "```\n", " val map = Map(\n", "        \"r\" -> Array.fill(64)(0),\n", "        \"n\" -> Array.fill(64)(0),\n", "        \"b\" -> Array.fill(64)(0),\n", "        \"k\" -> Array.fill(64)(0),\n", "        \"q\" -> Array.fill(64)(0),\n", "        \"p\" -> Array.fill(64)(0)\n", "      )\n", "```\n", "\n", "\n", "this map can be though of like this: the keys represent each piece (the colors are irrelevant) and the values are an array of size 64 \u2013 one slot for each square on the chess board. When a piece moves to a square we will increment the count in the array.\n", "\n", "\n", "```\n", "  val mmap = Map(\n", "        \"a8\"->0, \"b8\"->1, \"c8\"->2, \"d8\"->3, \"e8\"->4, \"f8\"->5, \"g8\"->6, \"h8\"->7,\n", "        \"a7\"->8, \"b7\"->9, \"c7\"->10,\"d7\"->11,\"e7\"->12,\"f7\"->13,\"g7\"->14,\"h7\"->15,\n", "        \"a6\"->16,\"b6\"->17,\"c6\"->18,\"d6\"->19,\"e6\"->20,\"f6\"->21,\"g6\"->22,\"h6\"->23,\n", "        \"a5\"->24,\"b5\"->25,\"c5\"->26,\"d5\"->27,\"e5\"->28,\"f5\"->29,\"g5\"->30,\"h5\"->31,\n", "        \"a4\"->32,\"b4\"->33,\"c4\"->34,\"d4\"->35,\"e4\"->36,\"f4\"->37,\"g4\"->38,\"h4\"->39,\n", "        \"a3\"->40,\"b3\"->41,\"c3\"->42,\"d3\"->43,\"e3\"->44,\"f3\"->45,\"g3\"->46,\"h3\"->47,\n", "        \"a2\"->48,\"b2\"->49,\"c2\"->50,\"d2\"->51,\"e2\"->52,\"f2\"->53,\"g2\"->54,\"h2\"->55,\n", "        \"a1\"->56,\"b1\"->57,\"c1\"->58,\"d1\"->59,\"e1\"->60,\"f1\"->61,\"g1\"->62,\"h1\"->63\n", "      )\n", "\n", "```\n", "\n", "this second mmap array is a mapping from the string (SAN) notation of a square to it\u2019s place the array that I mentioned above. We will need this because chesslib\u2019s internal representation of a chess board as an array is different than what we will be using. Now let\u2019s get to crunching those chess moves:\n", "\n", "```\n", "\n", " val key = moveData.flatMap(line=> {\n", "      // the maps above are here - omitted for readability\n", "      val cl = new ChessLib()\n", "      cl.reset()\n", "      val moves = line.split(\",\")\n", "      moves.foreach(move=> {\n", "        try {\n", "          val resultMove = Option(cl.move(move))\n", "          if (resultMove.nonEmpty) {\n", "            val piece = resultMove.get.piece\n", "            val to = resultMove.get.strTo\n", "            map(piece)(mmap(to)) += 1\n", "          }\n", "        } catch { case _ => }\n", "      })\n", "      map.toSeq\n", "    }).groupByKey()\n", "    val map1: RDD[(String, List[Array[Int]])] = key.map(x=> (x._1, x._2.toList))\n", "\n", "```\n", "\n", "we start by mapping each line in our input. We initialise a chesslib instance that we will use to process the moves and reset to the starting position of a game. Next we split the CSV into a list of moves and for each move we make chesslib play that move. The result of the move method contains the piece and the square that the move was made to. We take that square and increment the count in the array contained in the map. We will need some grouping to we convert the map into a sequence. So before the sequence the result will be something like\n", "\n", "\n", "```\n", "Map(\"r\"-> Array(10, 15, 20, 2, ...) //64 of these numbers\n", "Map(\"r\"-> Array(11, 25, 10, 1, ...) //64 of these numbers\n", "```\n", "\n", "\n", "after the conversion to a sequence we will have\n", "\n", "\n", "```\n", "(\"r\", Array(10, 15, 20, 2, ...)), (\"r\", Array(11, 25, 10, 1, ...)), ...\n", "\n", "```\n", "\n", "Why do we need this? because we will merge these maps to sum all the values in the arrays for each piece. The above example states that the rook was on a1 10 times in game 1 and 11 times in game 2. So the heat map will contains 21 for the rook on a1. When we group this sequence by key using the spark provided groupByKey method we will have the following result\n", "\n", "\n", "```\n", "(\"r\" -&gt; List(Array(10, 15, 20, 2, ...), Array(11, 25, 10, 1, ...) )\n", "```\n", "\n", "we need to add the corresponding indexes in each array to obtain our result. We will use a helper function for this called combineLists\n", "\n", "\n", "```\n", "def combineLists[A](ss:List[Array[A]]) =\n", "    (ss.head.map(List(_)) /: ss.tail)(_.zip(_).map(p=>p._2 :: p._1))\n", "```\n", "\n", "this methods takes a list of arrays, and returns a list of zipped lists. To for the input\n", "\n", "`List(1,2,3), List(5,6,7), List(7,8,9)`\n", "\n", "we will get the output\n", "\n", "Next we need to sum the values in the combined lists for a our final result\n", "\n", "\n", "```\n", "val map2: RDD[(String, List[Int])] = values.map(x=&gt; (x._1, x._2.map(_.sum).toList))\n", "```\n", "\n", "\n", "this will give us the total numbers of moves to each square for each piece. Just what we needed for the heat map!\n", "But we still need to do one more thing before we can start the rendering of the map and that is to normalise the values in the array to values between 0 and 1. We can do that using the feature normalisation formula\n", "\n", "![](http://imgur.com/l4gwnyv.png)\n", "\n", "the code is like this\n", "\n", "\n", "```\n", "val map3: RDD[(String, List[Double])] = map2.map(x=&gt; (x._1, x._2.map( y=> (y - x._2.min) / (x._2.max.toDouble - x._2.min) )))\n", "```\n", "\n", "\n", "now let\u2019s create our map files as HTML pages with a table containing the heat map\n", "\n", "\n", "```\n", "   map3.collect().foreach(rdd=> {\n", "      val tpl = html(rdd._1, rdd._2.mkString(\",\"))\n", "      new PrintWriter(outputDir + rdd._1 + \".html\") { write(tpl); close}\n", "    })\n", "\n", "```\n", "\n", "the html() function used here is a string template that uses the values between 0 and 1 to create a HLS color for a 5 color heat map. check out the code in the repo \u2013 it\u2019s too verbose to include it in this post.\n", "\n", "That\u2019s about it on how to generate a chess board heat map. Here are the results for 1.5M games analyzed:\n", "\n", "![](http://i.imgur.com/6hGU74G.png)\n", "\n", "![](http://imgur.com/PbJC7Kx.png)\n", "\n", "![](http://imgur.com/FHXDfVL.png)\n", "\n", "![](http://imgur.com/5I08pXS.png)\n", "\n", "![](http://imgur.com/HaHDp9E.png)\n", "\n", "![](http://imgur.com/UvNxeq7.png)\n", " \n", "\n", "\n", "\n", "\n"]}], "metadata": {"celltoolbar": "Tags", "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.12"}}, "nbformat": 4, "nbformat_minor": 4}
        </script>
    </head>
    <body>
        <div id="main">
            <div class="header">
            <div style="position: absolute; left:10px; top:5px;">
              <a href="/blog/about.html">about</a>
              <a href="/micro/micro.html">micro</a>
              <a href="/blogindex.html">macro</a>
            </div>
            <h1>Deniz's Weblog</h1>
            <p style="font-family: monospace;">
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
            </p>
            </div>
            <div id="notebook-holder"></div>
            <hr/>
            <div>
              <em>Generated on 2021-08-22 11:26:49</em>
            </div>
            <p>
              Questions or comments? Please take the time to compose an email and send it to <a href="mailto:deniz.dizman@gmail.com?subject=Question/Comment">me</a>.
              I will update the relevant page with our correspondence.
            </p>
        </div>
        <script>
          var src = document.getElementById("source");
          var notebook = nb.parse(JSON.parse(src.innerText));
          var rendered = notebook.render();
          document.getElementById("notebook-holder").appendChild(rendered);
        </script>
    </body>
</html>
