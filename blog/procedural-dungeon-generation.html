<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Deniz's personal pages</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <script src="/js/vendor/es5-shim.min.js"></script>
        <script src="/js/vendor/marked.min.js"></script>
        <!--script src="/js/vendor/purify.min.js"></script-->
        <script src="/js/vendor/ansi_up.min.js"></script>
        <script src="/js/vendor/prism.min.js"></script>
        <script src="/js/vendor/katex.min.js"></script>
        <script src="/js/vendor/katex-auto-render.min.js"></script>
	<script src="/js/vendor/notebook.js?_=2021-09-10 22:35:34"></script>
        <link rel="stylesheet" href="/css/vendor/katex.min.css" />
        <link rel="stylesheet" href="/css/vendor/prism.css" />
	<link rel="stylesheet" href="/css/notebook.css?2021-09-10 22:35:34" />
	<link rel="stylesheet" href="/css/nbpreview.css?2021-09-10 22:35:34" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet">
        <script type="application/text" id="source">
          {"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# procedural dungeon generation\n", "", "2017-05-13 [#gamedev](/tag/gamedev.html)\n"]}, {"cell_type": "markdown", "metadata": {"tags": ["gamedev"]}, "source": ["\n", "The basics of any roguelike dungeon crawling game is the dungeon. What makes these types of game infinitely replayable is their use of procedural generation to produce a new dungeon and artifacts for each game.  Some one in the internets came up with the idea of generating dungeons based on \"pushing out\" random rectangles generated with in a circle. To get more realistic results it's best to use a Gaussian random number generator, as rarely anything natural is uniformly randomly created. \n", "\n", "So create some random rectangles with in a cirlce:\n", "\n", "```\n", "\tfor i in range(0, num_cells):\n", "\t\tvar xy = get_xy()\n", "\t\tvar wh = get_wh()\n", "\t\tvar type = \"hall\"\n", "\t\tif wh.x * wh.y > mean_width * mean_height * 0.9:\n", "\t\t\ttype=\"room\"\n", "\t\tcells.append({\"id\": i, \"xy\": xy, \"wh\": wh, \"topleft\": xy, \"bottomright\": xy + wh, \"type\":type})\n", "\n", "```\n", "\n", "\n", "the get_xy makes sure that the top left lies in a circle:\n", "\n", "```\n", "\n", "func get_xy():\n", "\tvar r = 100 * randf()\n", "\tvar theta = randf() * 2 * PI\n", "\tvar x = r * cos(theta) + 300\n", "\tvar y = r * sin(theta) + 300\n", "\treturn Vector2(x,y)\n", "\n", "```\n", "\n", "make sure that the width, height is acceptable:\n", "\n", "```\n", "func get_wh():\n", "\tvar w = gaussian(mean_width, width_dev)\n", "\tvar h = gaussian(mean_height, height_dev)\n", "\tif w < 10 or h < 10: return get_wh()\n", "\treturn Vector2(w,h)\n", "```\n", "\n", "now push the rectangles outwards:\n", "\n", "```\n", "\twhile touching:\n", "\t\ttouching = false\n", "\t\tfor i in range(0, num_cells):\n", "\t\t\tfor j in range(i+1, num_cells):\n", "\t\t\t\tvar a = cells[i]\n", "\t\t\t\tvar b = cells[j]\n", "\t\t\t\tif touches(a, b):\n", "\t\t\t\t\ttouching = true\n", "\t\t\t\t\tvar dx = min(a[\"bottomright\"].x - b[\"topleft\"].x + padding, a[\"topleft\"].x - b[\"bottomright\"].x - padding)\n", "\t\t\t\t\tvar dy = min(a[\"bottomright\"].y - b[\"topleft\"].y + padding, a[\"topleft\"].y - b[\"bottomright\"].y - padding)\n", "\t\t\t\t\tif abs(dx) < abs(dy): dy = 0\n", "\t\t\t\t\telse: dx = 0\n", "\t\t\t\t\tvar dxa = -dx/2\n", "\t\t\t\t\tvar dxb = dx + dxa\n", "\t\t\t\t\tvar dya = -dy/2\n", "\t\t\t\t\tvar dyb = dy+dya\n", "\t\t\t\t\tshift_cell(a,Vector2(dxa, dya))\n", "\t\t\t\t\tshift_cell(b,Vector2(dxb, dyb))\n", "```\n", "\n", "\n", "Now some of the rectangles are designated as rooms if there are bigger than an average value in area.\n", "We want to use these as the main nodes for joining the rooms together.\n", "\n", "```\n", "\tcells.sort_custom(AreaSorter, \"sort\")\n", "\tvar num_rooms = 0\n", "\tfor c in cells:\n", "\t\tif c[\"type\"] == \"room\": num_rooms += 1\n", "\tfor i in range(0, min(num_rooms, num_corridor)):\n", "\t\tvar c = cells.pop_back()\n", "\t\trooms.append(c)\n", "```\n", "\n", "Now connect the main rooms using Relative Neighborhood Graphs [(RNG)](https://en.wikipedia.org/wiki/Relative_neighborhood_graph)\n", "\n", "```\n", "\t# connect main rooms\n", "\tvar ab_dist = 0\n", "\tvar ac_dist = 0\n", "\tvar bc_dist = 0\n", "\tvar skip = false\n", "\tfor i in range(0, rooms.size()):\n", "\t\tfor j in range(i+1, rooms.size()):\n", "\t\t\tskip = false\n", "\t\t\tab_dist = pow(center_x(rooms[i]) - center_x(rooms[j]), 2) + pow(center_y(rooms[i]) - center_y(rooms[j]), 2)\n", "\t\t\tfor k in range(0, rooms.size()):\n", "\t\t\t\tif i == k or j == k: continue\n", "\t\t\t\tac_dist = pow(center_x(rooms[i]) - center_x(rooms[k]), 2) + pow(center_y(rooms[i]) - center_y(rooms[k]), 2)\n", "\t\t\t\tbc_dist = pow(center_x(rooms[j]) - center_x(rooms[k]), 2) + pow(center_y(rooms[j]) - center_y(rooms[k]), 2)\n", "\t\t\t\tif ac_dist < ab_dist and bc_dist < ab_dist:\n", "\t\t\t\t\tskip = true\n", "\t\t\t\tif skip: break\n", "\t\t\t\n", "\t\t\tif not skip:\n", "\t\t\t\tif not rooms[i][\"id\"] in graph:\n", "\t\t\t\t\tgraph[rooms[i][\"id\"]] = []\n", "\t\t\t\tgraph[rooms[i][\"id\"]].append(rooms[j][\"id\"])\n", "```\n", "\n", "![img](/img/procgen_dungeons.png)\n", "\n", "The RNG construction and the overlap checking code is the brute force way of solving these problems. The overlap checking can be done using an interval search tree for a better runtime performance, and the wikipedia article mentions a paper with an algorithm to do it in linearithmic time. But since the number of rooms in a dungeon are relatively small, it's not worth the added code complexity\n", "\n"]}], "metadata": {"celltoolbar": "Tags", "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.12"}}, "nbformat": 4, "nbformat_minor": 4}
        </script>
    </head>
    <body>
        <div id="main">
            <div class="header">
            <div style="position: absolute; left:10px; top:5px;">
              <a href="/blog/about.html?2021-09-10 22:35:34">about</a>
              <a href="/micro/micro.html?2021-09-10 22:35:34">micro</a>
              <a href="/blogindex.html?2021-09-10 22:35:34">macro</a>
            </div>
            <h1>Deniz's Weblog</h1>
            <p style="font-family: monospace;">
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
            </p>
            </div>
            <div id="notebook-holder"></div>
            <hr/>
            <div>
              <em>Generated on 2021-09-10 22:35:34</em>
            </div>
            <p>
              Questions or comments? Please take the time to compose an email and send it to <a href="mailto:deniz.dizman@gmail.com?subject=Question/Comment">me</a>.
              I will update the relevant page with our correspondence.
            </p>
        </div>
        <script>
          var src = document.getElementById("source");
          var notebook = nb.parse(JSON.parse(src.innerText));
          var rendered = notebook.render();
          document.getElementById("notebook-holder").appendChild(rendered);
        </script>
    </body>
</html>
