<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Deniz's personal pages</title>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <script src="/js/vendor/es5-shim.min.js"></script>
        <script src="/js/vendor/marked.min.js"></script>
        <!--script src="/js/vendor/purify.min.js"></script-->
        <script src="/js/vendor/ansi_up.min.js"></script>
        <script src="/js/vendor/prism.min.js"></script>
        <script src="/js/vendor/katex.min.js"></script>
        <script src="/js/vendor/katex-auto-render.min.js"></script>
	<script src="/js/vendor/notebook.js?_=2021-08-03 23:38:03"></script>
        <link rel="stylesheet" href="/css/vendor/katex.min.css" />
        <link rel="stylesheet" href="/css/vendor/prism.css" />
	<link rel="stylesheet" href="/css/notebook.css?2021-08-03 23:38:03" />
	<link rel="stylesheet" href="/css/nbpreview.css?2021-08-03 23:38:03" />
  <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet">
        <script type="application/text" id="source">
          {"cells": [{"cell_type": "markdown", "metadata": {}, "source": ["# pgn parser with comments and recursive variations support\n", "", "2017-03-01 [#chess](/tag/chess.html)\n"]}, {"cell_type": "markdown", "metadata": {"tags": ["chess"]}, "source": ["\n", "PGN files are the standard way chess games are transmitted across the net. So any chess program that needs to replay or process a game needs to be able to read the PGN format.\n", "There are very many different PGN parsers around in different programming languages. Most of them try to process the PGN using regexes, or just reduce the data to the main\n", "line moves, event discarding the comments and annotations. This may be OK if you are processing the game for purposes of machine consumption as the comments don't mean\n", "anything to a machine but I wanted to write a parser that preserves the comments and the recursive variations. \n", "\n", "So the first part of any non trivial parser is going to be a \"Lexer\" that tokenizes the input. Check out the PGN formal grammar for \n", "ANTLR (https://github.com/antlr/grammars-v4/blob/master/pgn/PGN.g4) that has a details. \n", "It's a good idea to use this ANTLR code to if you don't want to fiddle with insides of a parser. \n", "\n", "So the lexer will consume the input character by character creating tokens from this input. Here is the token class that I used:\n", "\n", "<pre>\n", "    public class Token\n", "    {\n", "        public string Type { get; }\n", "        public string Value { get; }\n", "        public const string MoveNumber = \"MoveNumber\";\n", "        public const string SAN = \"SAN\";\n", "        public const string Comment = \"Comment\";\n", "        public const string EOF = \"EOF\";\n", "        public const string Result = \"Result\";\n", "        public const string Header = \"Header\";\n", "        public const string NAG = \"NAG\";\n", "        public const string LPAREN = \"LPAREN\";\n", "        public const string RPAREN = \"RPAREN\";\n", "        public Token(string type, string value)\n", "        {\n", "            Type = type;\n", "            Value = value.Replace(\"\\n\", \"\");\n", "        }\n", "\n", "        public override string ToString()\n", "        {\n", "            return \"Token \" + Type + \" \" + Value;\n", "        }\n", "    }\n", "</pre>\n", "\n", "We need to treat the left parenthesis and the right one as individual tokens as they will have a special meaning when we are creating the syntax tree. \n", "\n", "Diving deeper into the Lexer:\n", "\n", "<pre>\n", "        private int _position = 0;\n", "        private Char _currentChar;\n", "        private string _text;\n", "        private Boolean _lexingDone;\n", "\n", "        public PgnLexer(string pgnText)\n", "        {\n", "            _text = pgnText;\n", "            if (_text.Length > 0)\n", "                _currentChar = _text[_position];\n", "        }\n", "</pre>\n", "\n", "pretty simple, we need to do some book keeping - the current character pointer and the input data is stored.\n", "\n", "<pre>\n", "        private void Advance()\n", "        {\n", "            _position += 1;\n", "            if (_position >= _text.Length)\n", "            {\n", "                _lexingDone = true;\n", "            }\n", "            else\n", "            {\n", "                _currentChar = _text[_position];\n", "            }\n", "        }\n", "</pre>\n", "\n", "each time we consume a character the Advance() method will increment the pointer and check if all the input has been consumed. \n", "\n", "<pre>\n", "        private void SkipWhitespace()\n", "        {\n", "            while (!_lexingDone && \n", "                   (Char.IsWhiteSpace(_currentChar) || \n", "                                    _currentChar == '.' || \n", "                                    _currentChar == '\\n'))\n", "            {\n", "                Advance();\n", "            }\n", "        }\n", "</pre>\n", "Some PGN files are transcribed by humans and contain multiple whitespaces, some are computer programs inserting optional white spaces for\n", "better readability etc. The '.' character is also treaded as a white space as the move indication \"2... c4\" has multiple '.'\n", "characters that we'll skip.\n", "\n", "<pre>\n", "        public Token GetNextToken()\n", "        {\n", "            string result = \"\";\n", "            while (!_lexingDone)\n", "            {\n", "                //result += _currentChar;\n", "                if (_currentChar == '(')\n", "                {\n", "                    Advance();\n", "                    SkipWhitespace();\n", "                    return new Token(Token.LPAREN, result);\n", "                }\n", "\n", "                if (_currentChar == ')' && result.Trim().Equals(\"\"))\n", "                {\n", "                    Advance();\n", "                    SkipWhitespace();\n", "                    return new Token(Token.RPAREN, result);\n", "                }\n", "\n", "                if (_currentChar == '[')\n", "                {\n", "                    Advance();\n", "                    while (_currentChar != ']')\n", "                    {\n", "                        result += _currentChar;\n", "                        Advance();\n", "                    }\n", "                    Advance();\n", "                    SkipWhitespace();\n", "                    return new Token(Token.Header, result);\n", "                }\n", "                if (_currentChar == '.')\n", "                {\n", "                    SkipWhitespace();\n", "                    return new Token(Token.MoveNumber, result);\n", "                }\n", "\n", "                if (_currentChar == '{')\n", "                {\n", "                    while (_currentChar != '}')\n", "                    {\n", "                        Advance();\n", "                        result += _currentChar;\n", "                    }\n", "                    Advance();\n", "                    return new Token(Token.Comment, result.Replace(\"{\",\"\").Replace(\"}\",\"\"));\n", "                }\n", "\n", "                if ( (_currentChar == '\\n' ||_currentChar == ' ' || _currentChar == ')') && !result.Trim().Equals(\"\"))\n", "                {\n", "                    SkipWhitespace();\n", "                    result = result.Trim().Replace(\" \", \"\").Replace(\"\\n\", \"\");\n", "                    if (result.Equals(\"1-0\") || result.Equals(\"0-1\") || result.Equals(\"1/2-1/2\") || result.Equals(\"*\"))\n", "                        return new Token(Token.Result, result);\n", "                    if (result.StartsWith(\"$\"))\n", "                    {\n", "                        return new Token(Token.NAG, result);\n", "                    }\n", "                    return new Token(Token.SAN, result);\n", "                }\n", "\n", "                result += _currentChar;\n", "                Advance();\n", "\n", "            }\n", "            if (result.Equals(\"\"))\n", "                return new Token(Token.EOF, \"\");\n", "            return new Token(Token.Result, result);\n", "        }\n", "</pre>\n", "\n", "this is the real part that does the tokenization. Parenthesis type characters are consumed until the matching one is found, \n", "otherwise we consume until we reach a character that terminates a move element and return the resulting token. \n", "If we have consumed all the input we return the game result. Some PGN files may have extra white spaces at the end, \n", "so we return an EOF token if that's the case.\n", "\n", "\n", "Now that we can fetch the tokens from the file, we need to construct a tree representing the moves, comments, variations etc. in the PGN file. \n", "\n", "<pre>\n", "        private readonly PgnLexer _lexer;\n", "        private Token _currentToken;\n", "\n", "        public PgnParser(PgnLexer lexer)\n", "        {\n", "            _lexer = lexer;\n", "            _currentToken = lexer.GetNextToken();\n", "        }\n", "</pre>\n", "\n", "We need to track the currentToken and pass a reference to our lexer to fetch more tokens. \n", "\n", "This method will \"eat\" through the tokens and allow us to move forward in the processing:\n", "\n", "<pre>\n", "        private void Eat(string tokenType)\n", "        {\n", "            if (_currentToken.Type.Equals(tokenType))\n", "            {\n", "                _currentToken = _lexer.GetNextToken();\n", "            }\n", "            else\n", "            {\n", "                throw new Exception(\"Invalid syntax\");\n", "            }\n", "        }\n", "</pre>\n", "\n", "Take for example this made up PGN move text:\n", "\n", "\"1.e4 (11. f3 (111. f4 a7) a6) 1... e5 2.f4 exf4 (220... exf3) (221... exf2) 3.Nf3 g5 4.h4 ...\"\n", "\n", "(The move numbers are not correct even the moves may be illegal but the purpose is to illustrate the tree that we are aiming to build.)\n", "\n", "We want to transform this into the following tree:\n", "\n", "\n", "![image http://forum.dizman.org/assets/images/1-P17kH330Z1CMJ5qF.png](/img/1-P17kH330Z1CMJ5qF.png)\n", "\n", "All vertical connections are the next node connections and the horizontal connections are the variation connections. So \"e4\" move spawns a variation \n", "that it self has an embedded variation (hence the name recursive variations). The move \"exf4\" spawns 2 variations at this move. \n", "\n", "So we start with a method to transform the current token to a node:\n", "\n", "<pre>\n", " private Node Element()\n", "        {\n", "            if (_currentToken.Type.Equals(Token.SAN))\n", "            {\n", "                Node node = new SanNode();\n", "                node.Value = _currentToken.Value;\n", "                return node;\n", "            }\n", "\n", "            if (_currentToken.Type.Equals(Token.Result))\n", "            {\n", "                return new ResultNode();\n", "            }\n", "\n", "            if (_currentToken.Type.Equals(Token.MoveNumber))\n", "            {\n", "                var node = new MoveNumberNode();\n", "                node.Value = _currentToken.Value;\n", "                return node;\n", "            }\n", "\n", "            if (_currentToken.Type.Equals(Token.Header))\n", "            {\n", "                var node = new HeaderNode();\n", "                node.Value = _currentToken.Value;\n", "                return node;\n", "\n", "            }\n", "\n", "            if (_currentToken.Type.Equals(Token.Comment))\n", "            {\n", "                var node = new CommentNode();\n", "                node.Value = _currentToken.Value;\n", "                return node;\n", "            }\n", "            {\n", "                var node = new NullNode();\n", "                return node;\n", "            }\n", "\n", "        }\n", "</pre>\n", "\n", "So first the code to build the tree\n", "\n", "<pre>\n", "        private Stack<Node> _stack = new Stack<Node>();\n", "\n", "        private Node BuildTree(Node node)\n", "        {\n", "            Node root = node;\n", "            Node prevNode = node;\n", "            while (true)\n", "            {\n", "                Console.WriteLine(_currentToken);\n", "                if (_currentToken.Type.Equals(Token.EOF))\n", "                {\n", "                    return null;\n", "                }\n", "                var currentNode = Element();\n", "                if (currentNode.GetType() == typeof(ResultNode))\n", "                {\n", "                    Eat(_currentToken.Type);\n", "                    prevNode.Next = currentNode;\n", "                    return root;\n", "                }\n", "\n", "\n", "                if (_currentToken.Type.Equals(Token.LPAREN))\n", "                {\n", "                    _stack.Push(prevNode);\n", "                    prevNode.Next = currentNode;\n", "                    prevNode = prevNode.Next;\n", "                }\n", "\n", "                else if (_currentToken.Type.Equals(Token.RPAREN))\n", "                {\n", "                    prevNode.Next = currentNode;\n", "                    var t = _stack.Pop();\n", "                    t.Variations.Add(t.Next);\n", "                    prevNode = t;\n", "                    prevNode.Next = null;\n", "                }\n", "                else\n", "                {\n", "                    prevNode.Next = currentNode;\n", "                    prevNode = prevNode.Next;\n", "                }\n", "                Eat(_currentToken.Type);\n", "            }\n", "\n", "\n", "        }\n", "</pre>\n", "\n", "The algorithm is as follows:\n", "\n", "- Get the node type for the current token.\n", "- if it's a termination token return.\n", "- if it's not a LPAREN just eat the token and link the previous token to the current token.\n", "- if it's a LPAREN it means we are starting a recursive variation annotation (RVA). So push the previous node on the stack. Once we are done with the variation, we'll need to get this node back and continue the main line. Continue linking the next node to this node as if we were not in the RVA.\n", "- it we see a RPAREN pop the node on the stack and add the next pointer nodes to the variations list. Set the previous node to this node, and delete the next pointer for this node. \n", "\n", "So if we walk through an example move text of \"1. e4 (11. f3 a7) 1...e5 2.Nf3\" this is node state and stack state just before the RPAREN:\n", "\n", "\n", "![image http://forum.dizman.org/assets/images/1-awbP4CgiRNjLcGHB.png](/img/1-awbP4CgiRNjLcGHB.png)\n", "\n", "When we process the RPAREN we will pop the \"e4\" node from the stack, move the next pointers nodes to the variations, delete the next pointer and set the previous node to e4 and continue processing. \n", "\n", "\n", "![image http://forum.dizman.org/assets/images/1-XnoB3aI53wls76dH.png](/img/1-XnoB3aI53wls76dH.png)\n", "\n", "There the tree with embedded variations. The code I use actually takes care of further evaluating the tree into the chess model I use in the application by \n", "checking if the move in the PGN is valid, and adding the comments to the move etc. But this is the basics of parsing the PGN file. \n"]}], "metadata": {"celltoolbar": "Tags", "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"}, "language_info": {"codemirror_mode": {"name": "ipython", "version": 3}, "file_extension": ".py", "mimetype": "text/x-python", "name": "python", "nbconvert_exporter": "python", "pygments_lexer": "ipython3", "version": "3.6.12"}}, "nbformat": 4, "nbformat_minor": 4}
        </script>
    </head>
    <body>
        <div id="main">
            <div class="header">
            <div style="position: absolute; left:10px; top:5px;">
              <a href="/blog/about.html">about</a>
              <a href="/micro/micro.html">micro</a>
              <a href="/blogindex.html">macro</a>
            </div>
            <h1>Deniz's Weblog</h1>
            <p style="font-family: monospace;">
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
                <!-- a class="inverted" href="/tag/.html">/</a-->
            </p>
            </div>
            <div id="notebook-holder"></div>
            <hr/>
            <div>
              <em>Generated on 2021-08-03 23:38:03</em>
            </div>
            <p>
              Questions or comments? Please take the time to compose an email and send it to <a href="mailto:deniz.dizman@gmail.com?subject=Question/Comment">me</a>.
              I will update the relevant page with our correspondence.
            </p>
        </div>
        <script>
          var src = document.getElementById("source");
          var notebook = nb.parse(JSON.parse(src.innerText));
          var rendered = notebook.render();
          document.getElementById("notebook-holder").appendChild(rendered);
        </script>
    </body>
</html>
