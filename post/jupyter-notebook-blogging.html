<!DOCTYPE html>
<html lang="en">
  <head>
    <title> Blogging with jupyter notebooks</title>
      <meta charset="utf-8">
      <meta name="viewport" content="initial-scale=1">
      <link rel="stylesheet" href="/css/style.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
      <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
      <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
           onload="renderMathInElement(document.body);"></script>
    </head>
    <body>
        <div>
        <strong>
        <a href="/micro/micro-index.html" onClick="this.href+='?rnd='+new Date().getTime()">Micro</a> &middot; 
        <a href="/post/index.html" onClick="this.href+='?rnd='+new Date().getTime()">Macro</a> &middot; 
        <a href="/post/about.html">About</a> &middot; 
        <a href="/post/now.html">Now</a> &middot; 
        <a href="/post/fn.html">fn</a>
        &middot;
        <a href="/twtxt.txt">twtxt</a>
        </strong>
        </div>
        <hr />
        <div id="main">
        <h1 id="title"> Blogging with jupyter notebooks</h1>
        <div id="date"><em>created  2021-02-13 </em></div>
        <div class="content">
        <p>After I read Stephen Wolfram's very nerdy blog post about his productivity tools I was very intrigued by the idea that he was using Wolfram notebooks for almost everything he was producing. From documentation for his business to blog posts. The reason I find this a really cool idea is that you can include runnable in a post with it's output formatted as data frames or a mathplotlib graph. Jupyter is pretty flexible in the way it will allow you to produce output so you can go pretty wild like rendering your own SVG's etc.</p>
<h3>Migration from hugo</h3>
<p>I had been using hugo for a while now and everything I wrote was in markdown and Jupyter has built-in support for markdown. The only thing I needed to do was write a small python script that would embed the markdown files from hugo into jupyter notebooks (which are JSON and easy to understand). The only tricky part here was that hugo uses front matter to keep the metadata for posts while jupyter doesn't have such a feature. I ended up with creating a raw cell that holds this metadata and the second cell is the markdown cell that has the content.</p>
<h3>Notebook to HTML</h3>
<p>I had a couple of different options for generating the HTML from notebooks.</p>
<ul>
<li>Use the built-in HTML generation.</li>
<li>Get the markdown and export it to hugo or another markdown parser for the HTML</li>
<li>Use a different notebook viewer</li>
</ul>
<p>The built-in HTML generation is the easiest and most straight forward option but the resulting HTML was huge. A notebook with no image attachments was around 575Kb. I took a look at the templating system to see if I could optimize it but there was a lot of css compiled into the page and it looked pretty complicated so I didn't want to invest too much time into exploring this.</p>
<p>The markdown export was also a good idea but the main issue with this approach was processing the attachments. I tried a tool called <code>nbdev</code> which exports all the attachments to files but the links in the markdown document were not converted to the proper URL. It could be working for inline image generated by code cells but it will not work for attached images.</p>
<p>I also considered writing a script to extract the attachments and update the markdown links myself but that's also a lot of work and I would also have manage all the different cell types etc.</p>
<p>Then I explored the route of in-browser rendering. And not surprisingly there is a project called <code>notebook.js</code> which renders the notebook given the <code>ipynb</code> source. I ended up choosing this project and embedding the source file into the HTML.</p>
<h3>Index page generation</h3>
<p>There is no &quot;index page&quot; in the world of jupyter notebooks. You get a file explorer like interface and you choose your notebook. I needed something that displays the title, description and tags of the articles in a list. So I put together a script that traverses the notebooks and extracts the metadata from the first cell to create the index page.</p>
<h3>Tag pages and menu</h3>
<p>One of the great features of the hugo theme I was using before was the tag pages. But I couldn't be bothered to modify the theme to support a navigation bar with the tags. So I implemented both these features in the script I wrote for the notebook extractor.</p>
<h3>Microblog imap</h3>
<p>I recently shutdown my mastodon server because I could not justify paying 50$ for a server each month. But I don't like to post the occasional micro update and using a notebook for a short update is not practical. So I created a script that will monitor my email account for a certain email format and use it to create a new notebook with the content and publish it to the micro section on my website.</p>
<h3>Search</h3>
<p>Search is always complicated with static sites. When there is no server side code to power the search it stops making sense to create a reverse lookup index. So the method I came up with is to create the a mapping of the source for the posts to the file names and store that as JSON data to be processed by the client. So when you go to the search page you are basically downloading the entire text content of the posts in a single huge JSON along with the lemmatizations of the tokens in the body. Something like this</p>
<pre><code class="language-json">
{
...
&quot;implement&quot;: [&quot;implemented&quot;, &quot;implements&quot;, &quot;implementing&quot;], 
&quot;pay&quot;: [&quot;paying&quot;, &quot;pays&quot;, &quot;paid&quot;]
...
}

</code></pre>
<p>Then lemmatizing the input query to get the extended versions of the term and running a search for all these terms seems to yield good results and is fast enough. E.g if you were to search for &quot;paid&quot; the process would get the stem as &quot;pay&quot; then augment the search to include &quot;paying&quot;, &quot;pays&quot;, &quot;paid&quot; and return all the docs that contain these words too.</p>
<p>The ordering of the search results is something that needs more work but the there aren't that many documents to it's not that big of a deal.</p>
<p>Having a powerful environment that can evaluate and execute code will be great for technical writing!</p>
<pre><code>for i in range(3):
    print(&quot;More power!&quot;)
</code></pre>
<pre><code>More power!
More power!
More power!

</code></pre>

        </div>
        </div>
	<footer>
	<em>generated on 2021-10-03 13:54:52</em>
	</footer>
    </body>
</html>
