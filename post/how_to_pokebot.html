
<html lang="en">
    <head>
      <title>Deniz's personal pages</title>
      <meta charset="utf-8">
      <meta name="viewport" content="initial-scale=1">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
      <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>
      <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
           onload="renderMathInElement(document.body);"></script>
    </head>
    <body>
        <div>
        <strong>
        <a href="/micro/micro-index.html" onClick="this.href+='?rnd='+new Date().getTime()">Micro</a> | 
        <a href="/post/index.html" onClick="this.href+='?rnd='+new Date().getTime()">Macro</a> | 
        <a href="/post/about.html">About</a> |
        <a href="/post/now.html">Now</a> |
        <a href="/twtxt.txt">twtxt</a>
        </strong>
        </div>
        <hr />
        <div id="main">
        <h1 id="title"> How to Pokebot</h1>
        <div id="date"><em> 2007-01-01</em></div>
        <div class="content">
        <p><em>This a historic document that I found somewhere on my hard drive. It's incomplete
and the quality is very poor at best</em></p>
<h2>The devil: win32 API</h2>
<p>To capture the messages from the window of the poker client, had to be done with win api stuff. The other options that come to mind are:</p>
<ul>
<li>decrypt the network traffic between the poker room client and server, which is probably impossible</li>
<li>screen scrape the poker room client, which i think is a bad idea and hard to implement error prone etc.</li>
</ul>
<p>So we need to hook various api functions, ExtTextout, DrawText, etc. Tutorial about this stuff on the web are quite scarce, after quite a while of searching i came up with two simple code examples:</p>
<p>hookdll.c:</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#pragma data_seg(&quot;hookdata&quot;)
HHOOK oldkeyhook = 0;
#pragma data_seg()
#pragma comment(linker, &quot;/SECTION:hookdata,RWS&quot;)

#define DllExport  __declspec (dllexport)

DllExport LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam);
DllExport void InstallHook(int nCode);
DllExport void EndHook();

HINSTANCE hInst = NULL;

BOOL APIENTRY DllMain(HINSTANCE hInstance,DWORD  ul_reason_for_call,LPVOID lpReserved)
{
    switch(ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
 	   hInst = hInstance;
 	   break;
    case DLL_PROCESS_DETACH:
 	   break;
    case DLL_THREAD_ATTACH:
 	   break;
    case DLL_THREAD_DETACH:
 	   break;
    }
    return TRUE;
}

void InstallHook(int nCode)
{
    oldkeyhook = SetWindowsHookEx(WH_KEYBOARD, (HOOKPROC)KeyboardProc, hInst, 0);
}

DllExport LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wp, LPARAM lp)
{
    FILE *fp;
    if (nCode &gt;= 0)
    { 	  
 	   if ((lp &amp; 0x80000000) == 0x80000000)
 	   {
 		   fp = fopen(&quot;C:\\keys.txt&quot;,&quot;a+&quot;);
 		   char lpszName[0x100] = {0};
 		   GetKeyNameText(lp,lpszName,0xFF);
 		   fwrite(lpszName,strlen(lpszName),1, fp);
 		   fclose(fp); 	  
        }   
   }
   return CallNextHookEx(oldkeyhook,nCode,wp,lp);
}
void EndHook(void)
{
    UnhookWindowsHookEx(oldkeyhook);
}
</code></pre>
<p>hookexe.c:</p>
<pre><code>#include &lt;windows.h&gt;

LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);
char szClassName[ ] = &quot;mTn&quot;;

int WINAPI WinMain (HINSTANCE hThisInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR lpszArgument,
                    int nFunsterStil)

{
   
    MSG messages;           
    WNDCLASSEX wincl;       
    HWND hwnd; 
   
    wincl.hInstance = hThisInstance;
    wincl.lpszClassName = szClassName;
    wincl.lpfnWndProc = WindowProcedure;     
    wincl.style = CS_DBLCLKS;                
    wincl.cbSize = sizeof (WNDCLASSEX);

   
    wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION);
    wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION);
    wincl.hCursor = LoadCursor (NULL, IDC_ARROW);
    wincl.lpszMenuName = NULL;                
    wincl.cbClsExtra = 0;                     
    wincl.cbWndExtra = 0;                     
   
    wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND;

   
    if (!RegisterClassEx (&amp;wincl))
        return 0;

   
    hwnd = CreateWindowEx (
           0,                  
           szClassName,        
           &quot;mTn keyb hook&quot;,      
           WS_OVERLAPPEDWINDOW,
           CW_USEDEFAULT,      
           CW_USEDEFAULT,      
           190,                
           58,                
           HWND_DESKTOP,       
           NULL,               
           hThisInstance,      
           NULL                
           );

    ShowWindow (hwnd, nFunsterStil);

    while (GetMessage (&amp;messages, NULL, 0, 0))
    {
        TranslateMessage(&amp;messages);  
        DispatchMessage(&amp;messages);
    }
    return (int)messages.wParam;
}

LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   
    HWND hButton;
    HWND hButton1;
    static HMODULE hInsDll;
    HFONT hfDefault;
    void (*pInstallHook)(int);
    void (*pUninstallHook)(void);
    switch (message)                 
    {
       
 	   case WM_DESTROY:
            PostQuitMessage (0);      
            break;
        case WM_CREATE:
 		   hfDefault = (HFONT)GetStockObject(DEFAULT_GUI_FONT);//Sistem fontunu alýr
 		   hButton =  CreateWindow(&quot;button&quot;,&quot;HOOK ET&quot;,WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | WS_TABSTOP,0,0,80,24,hwnd,(HMENU)1001,((LPCREATESTRUCT)(lParam))-&gt;hInstance,NULL);
 		   SendMessage(hButton, WM_SETFONT, (WPARAM)hfDefault, MAKELPARAM(FALSE, 0)); //sistem fontunu kullandýrýr
 		   hButton1 =  CreateWindow(&quot;button&quot;,&quot;BIRAK&quot;,WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | WS_TABSTOP,90,0,90,24,hwnd,(HMENU)1002,((LPCREATESTRUCT)(lParam))-&gt;hInstance,NULL);
 		   SendMessage(hButton1, WM_SETFONT, (WPARAM)hfDefault, MAKELPARAM(FALSE, 0)); //sistem fontunu kullandýrýr
 		   hInsDll = LoadLibrary(&quot;kbHookDll.dll&quot;);
 		   break;
 	   case WM_COMMAND:
 		   switch(LOWORD(wParam))
 		   {
 			   case 1001:
 				   pInstallHook = (void (*)(int))GetProcAddress(hInsDll, &quot;InstallHook&quot;);
 				   pInstallHook(TRUE);
 				   break;

 			   case 1002:
 				   pUninstallHook = (void(*)(void))GetProcAddress(hInsDll,&quot;EndHook&quot;);
 				   pUninstallHook();
 				   break;
 		   }
 		   break;
        default:                     
            return DefWindowProc (hwnd, message, wParam, lParam);
    }
    return 0;
}
</code></pre>
<p>The exe file injects a system wide hook dll that intercepts the keyboard keypress api call and logs the key pressed into a file. A very simple key-logger if you will. The codes logic is pretty simple i think, you just reroute the original api call to yours, do the stuff you want and then call the original api method. The method used here is a method provided by the windows api, so there is nothing illegitimate with the method. But thebad news is that this type of hooking is only supported for hooking messages between windows and not gdi32 api calls, which we need. So we can't use this method on a poker room client, that disguises its log text</p>
<h2>Trying it Under Wine</h2>
<p>After failed attemps on win32 API programming I came up with the ingenious idea of running the poker desktop clients on linux, under the wine win32 API emulator.  We had a discussion about the pro/cons of this approach.
Pros:</p>
<ul>
<li>wine is open source, so easy access to the API implementation to override custom windows stealth behaviours.</li>
<li>No need to avoid poker room clients detection attempts, everything is in the wine source code</li>
</ul>
<p>Linux environment</p>
<p>Cons:</p>
<ul>
<li>Probably no source code to examine, need to hack wine codes by ourselves</li>
<li>User input simulation still remains a mystery</li>
</ul>
<p>Installing wine under debian etch, was quite easy. I just grabbed the source from the sourceforge page and untarred it. The configure script keeps bugging you for the dependencies, which where lib-png, lib-jpeg, flex, bison, libxml2 for me,on a minimal desktop installation of debian. The build time takes quite a while, ~1,5 million lines of code, but completes without errors.
Next up, download the pokerroom executable from their page, and run it under wine. Wine complained about missing DLLs such as mfc 4.2 and visual C runtime files. To satisfy this hunger we used winetricks from http://www.kegel.com/winetricks which is a small script that downloads and install the dependecy DLLs.
When you fire up wine, the poker room client executes complaining about some DLL being old, which is not important. After you try to login, it says that it can't connect to the login server. This is because wine hardware ID's are blacklisted. To overcome this, you need to patch wine to report a different hardware id. Here is the patch for version 0.9.30:</p>
<pre><code>diff -uNr wine-0.9.30-fe/dlls/advapi32/advapi.c wine-0.9.30-fe-patched/dlls/advapi32/advapi.c
--- wine-0.9.30-fe/dlls/advapi32/advapi.c	2007-01-25 07:53:50.000000000 -0800
+++ wine-0.9.30-fe-patched/dlls/advapi32/advapi.c	2007-02-22 16:50:15.000000000 -0800
@@ -112,11 +112,57 @@
*/
BOOL WINAPI GetCurrentHwProfileA(LPHW_PROFILE_INFOA pInfo)
{
-	FIXME(&quot;(%p) semi-stub\n&quot;, pInfo);
-	pInfo-&gt;dwDockInfo = DOCKINFO_DOCKED;
-	strcpy(pInfo-&gt;szHwProfileGuid,&quot;{12340001-1234-1234-1234-1233456789012}&quot;);
-	strcpy(pInfo-&gt;szHwProfileName,&quot;Wine Profile&quot;);
-	return 1;
+       CHAR profile[32];
+       DWORD type;
+       DWORD size;
+       DWORD ret;
+       DWORD val;
+       HKEY hkey;
+       BOOL profile_result = 0;
+
+       ret = RegOpenKeyA(HKEY_LOCAL_MACHINE, &quot;System\\CurrentControlSet\\Control\\IDConfigDB&quot;,
+                         &amp;hkey);
+
+       if (ret != ERROR_SUCCESS)
+               goto profile_error;
+
+       ret = RegGetValueA(hkey, NULL, &quot;CurrentConfig&quot;, RRF_RT_DWORD,
+                          &amp;type, &amp;val, &amp;size);
+       if (ret != ERROR_SUCCESS || size != 4 || type != REG_DWORD)
+               goto profile_error;
+
+       /* At least, I think the profile names are hex */
+       sprintf(profile, &quot;Hardware Profiles\\%04x&quot;, (WORD)(val &amp; 0xffff));
+
+       /* Set the profile name */
+       size = MAX_PROFILE_LEN;
+       ret = RegGetValueA(hkey, profile, &quot;FriendlyName&quot;, RRF_RT_REG_SZ,
+                          &amp;type, pInfo-&gt;szHwProfileName, &amp;size);
+
+       if (ret != ERROR_SUCCESS || type != REG_SZ)
+               goto profile_error;
+
+       /* Now get the GUID of this profile */
+       size = HW_PROFILE_GUIDLEN;
+       ret = RegGetValueA(hkey, profile, &quot;HwProfileGuid&quot;, RRF_RT_REG_SZ,
+                          &amp;type, pInfo-&gt;szHwProfileGuid, &amp;size);
+
+       if (ret != ERROR_SUCCESS || type != REG_SZ)
+               goto profile_error;
+
+       /* And finally the docking state */
+       ret = RegGetValueA(hkey, &quot;CurrentDockInfo&quot;, &quot;DockingState&quot;, RRF_RT_DWORD,
+                          &amp;type, &amp;pInfo-&gt;dwDockInfo, &amp;size);
+
+       if (ret != ERROR_SUCCESS || size != 4 || type != REG_DWORD)
+               goto profile_error;
+
+       /* Success */
+      profile_result = 1;
+
+profile_error:
+       RegCloseKey(hkey);
+      return profile_result;
}

/******************************************************************************
diff -uNr wine-0.9.30-fe/tools/wine.inf wine-0.9.30-fe-patched/tools/wine.inf
--- wine-0.9.30-fe/tools/wine.inf	2007-01-25 07:53:50.000000000 -0800
+++ wine-0.9.30-fe-patched/tools/wine.inf	2007-02-22 16:51:03.000000000 -0800
@@ -237,6 +237,22 @@
HKLM,System\CurrentControlSet\Control\Session Manager\Environment,&quot;windir&quot;,,&quot;%10%&quot;
HKLM,System\CurrentControlSet\Control\Session Manager\Environment,&quot;winsysdir&quot;,,&quot;%11%&quot;

+[IDConfigDB]
+HKLM,System\CurrentControlSet\Control\IDConfigDB,&quot;CurrentConfig&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB,&quot;UserWaitInterval&quot;,,0x0000001e
+HKLM,System\CurrentControlSet\Control\IDConfigDB,&quot;IsPortable&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Alias\0000,&quot;DockingState&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Alias\0000,&quot;Capabilities&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Alias\0000,&quot;DockID&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Alias\0000,&quot;SerialNumber&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Alias\0000,&quot;ProfileNumber&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles,&quot;Unknown&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles\0000,&quot;PreferenceOrder&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles\0000,&quot;FriendlyName&quot;,,&quot;Wine Profile&quot;
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles\0000,&quot;Aliasable&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles\0000,&quot;Cloned&quot;,,0x00000000
+HKLM,System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles\0000,&quot;HwProfileGuid&quot;,,&quot;{abba0009-1ed34-1dad4-1333-1e3e4ebb890a}&quot;
+
[Fonts]
HKLM,%FontSubStr%,&quot;Arial CE,238&quot;,,&quot;Arial,238&quot;
HKLM,%FontSubStr%,&quot;Arial CYR,204&quot;,,&quot;Arial,204&quot;
</code></pre>
<p>cd into the wine source installation directory and apply the patch with</p>
<pre><code>patch -p0 &lt; patch.txt
</code></pre>
<p>Next you need to install some registry keys. Put the following into a text file and import with regedit file.txt.</p>
<pre><code>REGEDIT4
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\IDConfigDB]
&quot;CurrentConfig&quot;=hex:00,00,00,00
&quot;IsPortable&quot;=hex:00,00,00,00
&quot;UserWaitInterval&quot;=hex:00,00,00,1e
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\IDConfigDB\Alias]
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\IDConfigDB\Alias\0000]
&quot;Capabilities&quot;=hex:00,00,00,00
&quot;DockID&quot;=hex:00,00,00,00
&quot;DockingState&quot;=hex:00,00,00,00
&quot;ProfileNumber&quot;=hex:00,00,00,00
&quot;SerialNumber&quot;=hex:00,00,00,00
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles]
&quot;Unknown&quot;=hex:00,00,00,00
[HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\IDConfigDB\Hardware Profiles\0000]
&quot;Aliasable&quot;=hex:00,00,00,00
&quot;Cloned&quot;=hex:00,00,00,00
&quot;FriendlyName&quot;=&quot;Wine Profile&quot;
&quot;HwProfileGuid&quot;=&quot;{abba0009-1ed34-1dad4-1333-1e3eb00a890a}&quot;
&quot;PreferenceOrder&quot;=hex:00,00,00,00
</code></pre>
<p>Build the source code, and install it.
After the installation process this is what you get:</p>
<p>Now that wine works, we need to hook the text drawing functions to capture the game log and process it.
Normally this would be an easy task under windows, but the poker rooms use tricks to prevent this from happening.
They use custom windows that override the WM_GETTEXT function that should return the contents of a control, and make it return nothing. So we have to hook the text displaying portion of the operating systems API, in this case the wine API.
This method resides in the file dlls/user32/text.c. For testing purposes add the following line into DrawTextExW():</p>
<pre><code>FIXME(&quot;%s, %d, [%s] %08x\n&quot;, debugstr_wn (str, count), count,
        wine_dbgstr_rect(rect), flags);
</code></pre>
<p>Now save the file and exit. Run the poker room client with wine, and watch the terminal output a lot of messages. Login to your account and sit at a table.
If you watch the terminal log, you'll see messages flying by with every little piece of text that is ever drawn on to the wine windows. This includes the game log that we are interested in. Now there are a few problems that we can identify here:</p>
<ul>
<li>we don't want to receive messages from the lobby windows, including garbage chat conversations.</li>
<li>Poker room developers tried make our lives harder by calling drawText for every word instead of sentences.</li>
<li>There are duplicate messages all over the place</li>
</ul>
<p>This is a screen shot of where we are now:</p>
<p><img src="/img/pokebot.png" alt="" /></p>
<h2>The Brain</h2>
<p>Before setting out to code and getting our hands dirty, the most scary part seemed to me the win 32 API stuff, probably because I've been a linux console/web programmer all my life, and i was never into windows and desktop client, especially low level - unmanaged windows API calls. But it seems there are a lot of resources and documents, and even managed code that hooks API calls (discussed in a different chapter). The real beast is the brain, the decision making part, the AI Server.</p>
<p>First off before discussing the actual algorithms and techniques, lets dicuss the architecture, and why it is called the AI Server. Simple: we'll have multiple poker room clients, playing on mutliple tables, some times even 2 of our bots playing on the same table, and sharing data, though one might think that this would decrease the winnings, and giving more rake, but this would increase our chances of winning more money from the other players. AI algorithms should be changable and tunable on the fly, and yet per AI Client (the Agent) configurable. The best design decision seemed like a client/server model, where the server was the AI Server, and the clients were the agents, that were the gateway between the AI and the poker room client. The AI Server's architectural crude design is like this:
[AIServer Diagram in Omnigraffle]</p>
<p>Flexibilty is a key design objective in most of the projects that get designed. This also was the case in the AI Server. Different algorithms had to be pluggable as modules, changeable according to table characteristics (heretic players, tight players, etc.) without the need of recompilation of code.</p>
<p>Multi-thread is a core requirement, because we'll be serving a lot of requests and clients</p>
<p>Cheating and using a application container such as tomcat doesn't help because HTTP is a stateless protocol, and poker is a statefull game. The state will have to be carried out by URL parameters or session/cookies which means that the agent will need to implement a HTTP client, which is not worth the effort. Instead we designed our own text based communication protocol. The protocol is TCP and Text based. Very simple, clients send commands and the server threads act accordingly.</p>

        </div>
        </div>
	<footer>
	generated on 2021-09-27 19:20:16
	</footer>    </body>
</html>
