<html lang="en">
    <head>
      <title>Deniz's personal pages</title>
      <meta charset="utf-8">
      <meta name="viewport" content="initial-scale=1">
      <!--script src="/js/vendor/es5-shim.min.js"></script>
      <script src="/js/vendor/ansi_up.min.js"></script>
      <script src="/js/vendor/prism.min.js"></script>
      <script src="/js/vendor/katex.min.js"></script>
      <script src="/js/vendor/katex-auto-render.min.js"></script>
      <link rel="stylesheet" href="/css/vendor/katex.min.css" />
      <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet"-->
    </head>
    <body>
        <div>
        <a href="/micro/micro-index.html?_=1632182678.2793894">Micro</a> | 
        <a href="/post/index.html?_=1632182678.2793894">Macro</a> | 
        <a href="/post/about.html">About</a>
        </div>
        <hr />
        <div id="main">
        <h1 id="title"> E-commerce SDLC</h1>
        <div id="date"><em> 2012-04-13</em></div>
        <p>Working in a different industry that has different demands, and brings different challenges to the table, is a thrilling experience. During my time in the development process for end-user applications and telecom applications never have I seen the chaos and change rate and pace that I have seen in the aggressive e-commerce industry. Using processes and methods that you are accustomed to from other industries just does not cut it here. Managing development for an e-commerce site is like funneling chaos through a pin hole. Committing to issues/tasks on a (bi)weekly basis is a dream in this ever so fast transforming universe. So you have to devise a new method of making the production line run. So here is exactly what is not working:</p>
<ul>
<li>Choose N number of issues, and try to get them developed by time X</li>
<li>Get them tested.</li>
<li>Fix reopened stuff.</li>
<li>Get the reopens tested</li>
<li>deploy live</li>
</ul>
<p>The bad thing about the first step is that, by the time you are half way through the N chosen issues, something new with a higher priority than everything else pops up, that must be done now. It is almost impossible to eliminate this interference without loosing competitive edge.</p>
<p>The bad thing about the second item is that the QA team is working constantly in burst loads. One minute they don’t have anything related to the release, the next minute they are expected to test N issues in a short time.</p>
<p>The bad thing about the 3rd item is that QA is idle again waiting for a new release with the fixes.This can be mitigated by opting to continue the tests even if a bug is found, and sending all fixed reopened items to test later. This is trading off robustness for speed, as ideally the test would stop, the bug would be fixed, and the tests would start from the beginning, in case that bug has caused any side effects.</p>
<p>The 4th item can also be avoided by not submitting reopened items at all (except for really crucial issues), and waiting for the next release to deploy them.</p>
<p>So this usual way of developing is not suited for such a fast changing environment. Here is the alternative method we are experimenting with</p>
<ul>
<li>every task is assign a priority during creating</li>
<li>every body picks the next most important task from the pool</li>
<li>every hour the release manager integrates any finished task to the development branch, from the topic branch of that issue</li>
<li>the QA team constantly tests the issues that are integrated into the development branch</li>
<li>if there is a reopen it sent back to the developer every six hours the release manager selects all the issues that have passed testing in the development branch and integrates them into the release branch</li>
<li>QA runs an integration test on the release branch</li>
<li>if there is a task breaking integration, it is unmerged</li>
<li>deployment is done every day</li>
</ul>
<p>I think the major advantages of this type of development cycle is that the future-reopen issues aren’t loosing time waiting to be included in a release but are tested on the spot, and are never merged into a release. Also another great advantage is that the load distribution on the QA team is evened out. I will publish some empirical data on both processes once I have collected enough for the second process type.</p>
<p>Having a test server that is independent of cocky sys-admins is crucial to the success of this methodology. You absolutely need a smaller version of your live environment at your finger tips, that you can break restore at will.</p>
<p>A further improvement will be added by actually being able to test each issue in isolation in it’s own branch. This brings the problem of having to cope with DB changes (since each branch’s deployed code will be using the same DB) that may lead to conflict.</p>

        </div>
    </body>
</html>
