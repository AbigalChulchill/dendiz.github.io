<html lang="en">
    <head>
      <title>Deniz's personal pages</title>
      <meta charset="utf-8">
      <meta name="viewport" content="initial-scale=1">
      <link rel="stylesheet" href="/css/style.css" />
      <!--script src="/js/vendor/es5-shim.min.js"></script>
      <script src="/js/vendor/ansi_up.min.js"></script>
      <script src="/js/vendor/prism.min.js"></script>
      <script src="/js/vendor/katex.min.js"></script>
      <script src="/js/vendor/katex-auto-render.min.js"></script>
      <link rel="stylesheet" href="/css/vendor/katex.min.css" />
      <link href="https://fonts.googleapis.com/css?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,300;1,400;1,500;1,700;1,900|Roboto+Mono:300,300i,400,400i,500,500i,700,700i&amp;display=swap" rel="stylesheet"-->
    </head>
    <body>
        <div>
        <a href="/micro/micro-index.html?_=1632193761.0148551">Micro</a> | 
        <a href="/post/index.html?_=1632193761.0148551">Macro</a> | 
        <a href="/post/about.html">About</a>
        </div>
        <hr />
        <div id="main">
        <h1 id="title"> Epic4x: Devlog #10</h1>
        <div id="date"><em> 2017-03-09</em></div>
        <p>Posted on March 9, 2017 by dendiz
Today I got around to actually implementing the command system. I had to dig 
deep into spring to get the kind of class/object interaction that I was talking 
about. The commands are beans and hibernate entities at the same time. The 
issued command is persisted in the database after validation based on the 
components that the commands affected ship has. So if you want to issue a move 
command the ship must have an engine. At each turn the commands are read from 
the database and their execute method is called which actually does the 
operations like updating a ships x/y coordinates. Hibernate can infer the type
of the object after reading the database entity and call the correct execute
method. Each command extends from a base abstract command object which contains
all the parameters that each command will use. This is a bit off as an “attack” 
command will not need a destination planet field but will inherit one anyway, 
but the execute method will know which parameters to use anyway.</p>
<p>The most challenging part was figuring out how to instantiate a spring bean with
constructor parameters. A move command is a bean but needs the parameters 
“destination planet” and “ship” at construction. The trick was using something 
like this:</p>
<pre><code class="language-java">factory = applicationContext.getAutowireCapableBeanFactory();
Iterable&lt;Command&gt; commands = commandRepository.findAll();
for (Command command : commands) {
   factory.autowireBean(command);
   factory.initializeBean(command, command.getClass().getSimpleName());
   command.execute();
}
</code></pre>
<p>commands are created with constructor parameters and saved in the database and 
augmented to a spring bean with this code.</p>

        </div>
    </body>
</html>
